package santa.runtime

import kotlinx.collections.immutable.toPersistentList
import santa.runtime.value.*
import kotlin.math.floor

/**
 * Runtime operators for santa-lang bytecode.
 *
 * These static methods are called from generated bytecode to implement
 * operators that require dynamic dispatch based on operand types.
 */
object Operators {

    /**
     * Unary negation: -x
     * Works for Integer and Decimal.
     */
    @JvmStatic
    fun negate(value: Value): Value = when (value) {
        is IntValue -> IntValue(-value.value)
        is DecimalValue -> DecimalValue(-value.value)
        else -> throw SantaRuntimeException("Cannot negate ${value.typeName()}")
    }

    /**
     * Addition: a + b
     * - Integers/Decimals: Numeric addition (left type determines result)
     * - Strings: Concatenation (left string coerces right to string)
     * - Lists: Concatenation
     * - Sets: Union
     * - Dictionaries: Merge (right precedence)
     */
    @JvmStatic
    fun add(left: Value, right: Value): Value = when (left) {
        is IntValue -> when (right) {
            is IntValue -> IntValue(left.value + right.value)
            is DecimalValue -> IntValue((left.value + right.value).toLong())
            else -> throw SantaRuntimeException("Cannot add ${left.typeName()} and ${right.typeName()}")
        }
        is DecimalValue -> when (right) {
            is IntValue -> DecimalValue(left.value + right.value)
            is DecimalValue -> DecimalValue(left.value + right.value)
            else -> throw SantaRuntimeException("Cannot add ${left.typeName()} and ${right.typeName()}")
        }
        is StringValue -> {
            val rightStr = when (right) {
                is StringValue -> right.value
                is IntValue -> right.value.toString()
                is DecimalValue -> right.value.toString()
                is BoolValue -> right.value.toString()
                is NilValue -> "nil"
                else -> throw SantaRuntimeException("Cannot convert ${right.typeName()} to String")
            }
            StringValue(left.value + rightStr)
        }
        is ListValue -> when (right) {
            is ListValue -> left.concat(right)
            else -> throw SantaRuntimeException("Cannot add ${left.typeName()} and ${right.typeName()}")
        }
        is SetValue -> when (right) {
            is SetValue -> left.union(right)
            else -> throw SantaRuntimeException("Cannot add ${left.typeName()} and ${right.typeName()}")
        }
        is DictValue -> when (right) {
            is DictValue -> left.merge(right)
            else -> throw SantaRuntimeException("Cannot add ${left.typeName()} and ${right.typeName()}")
        }
        else -> throw SantaRuntimeException("Cannot add ${left.typeName()} and ${right.typeName()}")
    }

    /**
     * Subtraction: a - b
     * - Integers/Decimals: Numeric subtraction (left type determines result)
     * - Sets: Set difference
     */
    @JvmStatic
    fun subtract(left: Value, right: Value): Value = when (left) {
        is IntValue -> when (right) {
            is IntValue -> IntValue(left.value - right.value)
            is DecimalValue -> IntValue((left.value - right.value).toLong())
            else -> throw SantaRuntimeException("Cannot subtract ${right.typeName()} from ${left.typeName()}")
        }
        is DecimalValue -> when (right) {
            is IntValue -> DecimalValue(left.value - right.value)
            is DecimalValue -> DecimalValue(left.value - right.value)
            else -> throw SantaRuntimeException("Cannot subtract ${right.typeName()} from ${left.typeName()}")
        }
        is SetValue -> when (right) {
            is SetValue -> left.difference(right)
            else -> throw SantaRuntimeException("Cannot subtract ${right.typeName()} from ${left.typeName()}")
        }
        else -> throw SantaRuntimeException("Cannot subtract ${right.typeName()} from ${left.typeName()}")
    }

    /**
     * Multiplication: a * b
     * - Integers/Decimals: Numeric multiplication (left type determines result)
     * - Strings: Repetition (string * integer)
     * - Lists: Repetition (list * integer)
     */
    @JvmStatic
    fun multiply(left: Value, right: Value): Value = when (left) {
        is IntValue -> when (right) {
            is IntValue -> IntValue(left.value * right.value)
            is DecimalValue -> IntValue((left.value * right.value).toLong())
            else -> throw SantaRuntimeException("Cannot multiply ${left.typeName()} and ${right.typeName()}")
        }
        is DecimalValue -> when (right) {
            is IntValue -> DecimalValue(left.value * right.value)
            is DecimalValue -> DecimalValue(left.value * right.value)
            else -> throw SantaRuntimeException("Cannot multiply ${left.typeName()} and ${right.typeName()}")
        }
        is StringValue -> when (right) {
            is IntValue -> StringValue(left.value.repeat(right.value.toInt()))
            else -> throw SantaRuntimeException("Cannot multiply ${left.typeName()} and ${right.typeName()}")
        }
        is ListValue -> when (right) {
            is IntValue -> left.repeat(right.value.toInt())
            else -> throw SantaRuntimeException("Cannot multiply ${left.typeName()} and ${right.typeName()}")
        }
        else -> throw SantaRuntimeException("Cannot multiply ${left.typeName()} and ${right.typeName()}")
    }

    /**
     * Division: a / b
     * - Integers: Floored division (Python-style, floors toward negative infinity)
     * - Decimals: Floating-point division
     */
    @JvmStatic
    fun divide(left: Value, right: Value): Value = when (left) {
        is IntValue -> when (right) {
            is IntValue -> IntValue(floorDiv(left.value, right.value))
            is DecimalValue -> IntValue(floor(left.value / right.value).toLong())
            else -> throw SantaRuntimeException("Cannot divide ${left.typeName()} by ${right.typeName()}")
        }
        is DecimalValue -> when (right) {
            is IntValue -> DecimalValue(left.value / right.value)
            is DecimalValue -> DecimalValue(left.value / right.value)
            else -> throw SantaRuntimeException("Cannot divide ${left.typeName()} by ${right.typeName()}")
        }
        else -> throw SantaRuntimeException("Cannot divide ${left.typeName()} by ${right.typeName()}")
    }

    /**
     * Modulo: a % b
     * - Integers: Remainder using floored division (Python-style, result sign matches divisor)
     */
    @JvmStatic
    fun modulo(left: Value, right: Value): Value = when (left) {
        is IntValue -> when (right) {
            is IntValue -> IntValue(floorMod(left.value, right.value))
            else -> throw SantaRuntimeException("Cannot compute ${left.typeName()} % ${right.typeName()}")
        }
        else -> throw SantaRuntimeException("Cannot compute ${left.typeName()} % ${right.typeName()}")
    }

    /**
     * Equality: a == b
     * Structural equality for all types.
     */
    @JvmStatic
    fun equal(left: Value, right: Value): Value = BoolValue.box(left == right)

    /**
     * Inequality: a != b
     */
    @JvmStatic
    fun notEqual(left: Value, right: Value): Value = BoolValue.box(left != right)

    /**
     * Less than: a < b
     * Works for Integer, Decimal, and String.
     */
    @JvmStatic
    fun lessThan(left: Value, right: Value): Value = BoolValue.box(compare(left, right) < 0)

    /**
     * Less than or equal: a <= b
     */
    @JvmStatic
    fun lessOrEqual(left: Value, right: Value): Value = BoolValue.box(compare(left, right) <= 0)

    /**
     * Greater than: a > b
     */
    @JvmStatic
    fun greaterThan(left: Value, right: Value): Value = BoolValue.box(compare(left, right) > 0)

    /**
     * Greater than or equal: a >= b
     */
    @JvmStatic
    fun greaterOrEqual(left: Value, right: Value): Value = BoolValue.box(compare(left, right) >= 0)

    /**
     * Logical NOT: !x
     * Returns false for truthy values, true for falsy values.
     */
    @JvmStatic
    fun not(value: Value): BoolValue = BoolValue.box(!value.isTruthy())

    /**
     * Check if a value is truthy for conditional branching.
     */
    @JvmStatic
    fun isTruthy(value: Value): Boolean = value.isTruthy()

    /**
     * Index operator: target[index]
     * - Lists: get element at index (negative indices count from end, out of bounds = nil)
     *          or slice with range (target[1..3])
     * - Strings: get grapheme cluster at index (negative indices count from end, out of bounds = nil)
     *            or slice with range (target[1..3])
     * - Dictionaries: get value for key (missing key = nil)
     */
    @JvmStatic
    fun index(target: Value, index: Value): Value = when (target) {
        is ListValue -> when (index) {
            is IntValue -> target.get(index.value.toInt())
            is RangeValue -> {
                val start = index.getStart().toInt()
                val end = if (index.isUnbounded()) {
                    target.size()
                } else {
                    index.getEndExclusive()!!.toInt()
                }
                target.slice(start, end)
            }
            else -> throw SantaRuntimeException("List index must be Integer or Range, got ${index.typeName()}")
        }
        is StringValue -> when (index) {
            is IntValue -> {
                val grapheme = target.graphemeAt(index.value.toInt())
                if (grapheme != null) StringValue(grapheme) else NilValue
            }
            is RangeValue -> {
                val start = index.getStart().toInt()
                val end = if (index.isUnbounded()) {
                    target.graphemeLength()
                } else {
                    index.getEndExclusive()!!.toInt()
                }
                StringValue(target.graphemeSlice(start, end))
            }
            else -> throw SantaRuntimeException("String index must be Integer or Range, got ${index.typeName()}")
        }
        is DictValue -> target.get(index)
        else -> throw SantaRuntimeException("Cannot index ${target.typeName()}")
    }

    /**
     * Pipeline: a |> f
     * Passes left value as argument to right function.
     */
    @JvmStatic
    fun pipeline(value: Value, func: Value): Value {
        if (func !is FunctionValue) {
            throw SantaRuntimeException("Pipeline right-hand side must be a Function, got ${func.typeName()}")
        }
        return func.invoke(listOf(value))
    }

    /**
     * Composition: f >> g
     * Creates a new function that applies f first, then g.
     */
    @JvmStatic
    fun compose(first: Value, second: Value): Value {
        if (first !is FunctionValue) {
            throw SantaRuntimeException("Compose left-hand side must be a Function, got ${first.typeName()}")
        }
        if (second !is FunctionValue) {
            throw SantaRuntimeException("Compose right-hand side must be a Function, got ${second.typeName()}")
        }
        return ComposedFunctionValue(first, second)
    }

    /**
     * Convert a Java List<Value> to a ListValue.
     * Used by codegen for rest parameters.
     */
    @JvmStatic
    @Suppress("UNCHECKED_CAST")
    fun listFromJavaList(list: List<*>): ListValue {
        return ListValue((list as List<Value>).toPersistentList())
    }

    /**
     * Spread a collection into an ArrayList being built for function call arguments.
     * Mutates the list and returns Unit (the list reference itself is preserved).
     */
    @JvmStatic
    @Suppress("UNCHECKED_CAST")
    fun spreadIntoJavaList(list: java.util.ArrayList<*>, spread: Value) {
        val mutableList = list as java.util.ArrayList<Value>
        when (spread) {
            is ListValue -> mutableList.addAll(spread.elements)
            is SetValue -> mutableList.addAll(spread.elements)
            is RangeValue -> {
                if (spread.isUnbounded()) {
                    throw SantaRuntimeException("Cannot spread unbounded range into arguments")
                }
                spread.toList().forEach { mutableList.add(IntValue(it)) }
            }
            else -> throw SantaRuntimeException("Cannot spread ${spread.typeName()} into arguments")
        }
    }

    /**
     * Spread a collection into a PersistentList being built.
     * Used by codegen for spread syntax in list literals: [1, ..xs, 2]
     */
    @JvmStatic
    fun spreadIntoList(
        list: kotlinx.collections.immutable.PersistentList<Value>,
        spread: Value
    ): kotlinx.collections.immutable.PersistentList<Value> = when (spread) {
        is ListValue -> list.addAll(spread.elements)
        is SetValue -> list.addAll(spread.elements)
        is RangeValue -> {
            if (spread.isUnbounded()) {
                throw SantaRuntimeException("Cannot spread unbounded range into list")
            }
            list.addAll(spread.toList().map { IntValue(it) })
        }
        else -> throw SantaRuntimeException("Cannot spread ${spread.typeName()} into list")
    }

    /**
     * Spread a collection into a PersistentSet being built.
     * Used by codegen for spread syntax in set literals: {1, ..xs, 2}
     */
    @JvmStatic
    fun spreadIntoSet(
        set: kotlinx.collections.immutable.PersistentSet<Value>,
        spread: Value
    ): kotlinx.collections.immutable.PersistentSet<Value> = when (spread) {
        is ListValue -> set.addAll(spread.elements)
        is SetValue -> set.addAll(spread.elements)
        is RangeValue -> {
            if (spread.isUnbounded()) {
                throw SantaRuntimeException("Cannot spread unbounded range into set")
            }
            set.addAll(spread.toList().map { IntValue(it) })
        }
        else -> throw SantaRuntimeException("Cannot spread ${spread.typeName()} into set")
    }

    /** Compare two values. Returns negative if left < right, 0 if equal, positive if left > right. */
    @JvmStatic
    fun compare(left: Value, right: Value): Int = when (left) {
        is IntValue -> when (right) {
            is IntValue -> left.value.compareTo(right.value)
            is DecimalValue -> left.value.toDouble().compareTo(right.value)
            else -> throw SantaRuntimeException("Cannot compare ${left.typeName()} and ${right.typeName()}")
        }
        is DecimalValue -> when (right) {
            is IntValue -> left.value.compareTo(right.value.toDouble())
            is DecimalValue -> left.value.compareTo(right.value)
            else -> throw SantaRuntimeException("Cannot compare ${left.typeName()} and ${right.typeName()}")
        }
        is StringValue -> when (right) {
            is StringValue -> left.value.compareTo(right.value)
            else -> throw SantaRuntimeException("Cannot compare ${left.typeName()} and ${right.typeName()}")
        }
        else -> throw SantaRuntimeException("Cannot compare ${left.typeName()} and ${right.typeName()}")
    }

    // Helper: Floored division (Python-style)
    private fun floorDiv(a: Long, b: Long): Long {
        var q = a / b
        if ((a xor b) < 0 && q * b != a) {
            q--
        }
        return q
    }

    // Helper: Floored modulo (Python-style)
    private fun floorMod(a: Long, b: Long): Long {
        return a - floorDiv(a, b) * b
    }
}

/**
 * Runtime exception for santa-lang errors.
 */
class SantaRuntimeException(message: String) : RuntimeException(message)
