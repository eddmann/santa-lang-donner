package santa.runtime

import santa.runtime.value.*
import kotlinx.collections.immutable.persistentListOf
import kotlinx.collections.immutable.persistentSetOf
import kotlinx.collections.immutable.toPersistentList
import kotlinx.collections.immutable.toPersistentSet
import kotlinx.collections.immutable.persistentMapOf
import java.math.RoundingMode
import java.math.BigDecimal

/**
 * Built-in functions for santa-lang.
 *
 * These functions are called from generated bytecode via static dispatch.
 */
object Builtins {

    /**
     * Path to the currently executing source file.
     * Set by the CLI before execution to enable relative file lookups.
     */
    @JvmField
    var sourceFilePath: String? = null

    /**
     * size(collection) - Returns the size of a collection.
     */
    @JvmStatic
    fun size(value: Value): Value = when (value) {
        is ListValue -> IntValue(value.size().toLong())
        is SetValue -> IntValue(value.size().toLong())
        is DictValue -> IntValue(value.size().toLong())
        is StringValue -> IntValue(value.graphemeLength().toLong())
        else -> throw SantaRuntimeException("size: expected collection, got ${value.typeName()}")
    }

    /**
     * first(collection) - Returns the first element or nil.
     */
    @JvmStatic
    fun first(value: Value): Value = when (value) {
        is ListValue -> value.get(0)
        is StringValue -> {
            val grapheme = value.graphemeAt(0)
            if (grapheme != null) StringValue(grapheme) else NilValue
        }
        is LazySequenceValue -> value.generator().firstOrNull() ?: NilValue
        else -> throw SantaRuntimeException("first: expected List or String, got ${value.typeName()}")
    }

    /**
     * rest(collection) - Returns all elements except the first.
     */
    @JvmStatic
    fun rest(value: Value): Value = when (value) {
        is ListValue -> if (value.size() <= 1) {
            ListValue(persistentListOf())
        } else {
            value.slice(1, value.size())
        }
        is StringValue -> StringValue(value.graphemeSlice(1, value.graphemeLength()))
        is LazySequenceValue -> {
            val seq = value.generator()
            LazySequenceValue.fromGenerator { seq.drop(1) }
        }
        else -> throw SantaRuntimeException("rest: expected List or String, got ${value.typeName()}")
    }

    /**
     * push(value, collection) - Returns a new collection with value appended.
     */
    @JvmStatic
    fun push(value: Value, collection: Value): Value = when (collection) {
        is ListValue -> ListValue(collection.elements.add(value))
        is SetValue -> SetValue(collection.elements.add(value))
        else -> throw SantaRuntimeException("push: expected List or Set, got ${collection.typeName()}")
    }

    /**
     * int(value) - Converts value to integer. Returns 0 for unparseable strings.
     * Decimals are rounded to nearest, with half rounding away from zero.
     */
    @JvmStatic
    fun int(value: Value): Value = when (value) {
        is IntValue -> value
        is DecimalValue -> {
            // Round half away from zero per LANG.txt
            // For positive: 3.5 → 4 (use HALF_UP)
            // For negative: -3.5 → -4 (use HALF_UP on absolute, then negate)
            val d = value.value
            val rounded = if (d >= 0) {
                BigDecimal(d).setScale(0, RoundingMode.HALF_UP).toLong()
            } else {
                -BigDecimal(-d).setScale(0, RoundingMode.HALF_UP).toLong()
            }
            IntValue(rounded)
        }
        is StringValue -> {
            val cleaned = value.value.trim().replace("_", "")
            IntValue(cleaned.toLongOrNull() ?: 0L)
        }
        is BoolValue -> IntValue(if (value.value) 1L else 0L)
        else -> throw SantaRuntimeException("int: cannot convert ${value.typeName()} to Integer")
    }

    /**
     * type(value) - Returns the type name as a string.
     */
    @JvmStatic
    fun type(value: Value): Value = StringValue(value.typeName())

    /**
     * keys(dict) - Returns the keys of a dictionary as a list.
     */
    @JvmStatic
    fun keys(value: Value): Value = when (value) {
        is DictValue -> value.keys()
        else -> throw SantaRuntimeException("keys: expected Dictionary, got ${value.typeName()}")
    }

    /**
     * values(dict) - Returns the values of a dictionary as a list.
     */
    @JvmStatic
    fun values(value: Value): Value = when (value) {
        is DictValue -> value.values()
        else -> throw SantaRuntimeException("values: expected Dictionary, got ${value.typeName()}")
    }

    /**
     * abs(n) - Returns the absolute value.
     */
    @JvmStatic
    fun abs(value: Value): Value = when (value) {
        is IntValue -> IntValue(kotlin.math.abs(value.value))
        is DecimalValue -> DecimalValue(kotlin.math.abs(value.value))
        else -> throw SantaRuntimeException("abs: expected Integer or Decimal, got ${value.typeName()}")
    }

    // =========================================================================
    // Type Conversion Functions (LANG.txt §11.1)
    // =========================================================================

    /**
     * ints(string) - Extract all parseable integers from a string using regex (-?[0-9]+).
     */
    @JvmStatic
    fun ints(value: Value): Value = when (value) {
        is StringValue -> {
            val pattern = Regex("-?[0-9]+")
            val matches = pattern.findAll(value.value)
                .mapNotNull { it.value.toLongOrNull() }
                .map { IntValue(it) as Value }
                .toList()
            ListValue(matches.toPersistentList())
        }
        else -> throw SantaRuntimeException("ints: expected String, got ${value.typeName()}")
    }

    /**
     * evaluate(string) - Parse a JSON-like literal string into a value.
     * Supports integers and nested lists: "42" -> 42, "[1,[2,3]]" -> [1,[2,3]]
     */
    @JvmStatic
    fun evaluate(value: Value): Value = when (value) {
        is StringValue -> parseValue(value.value.trim())
        else -> throw SantaRuntimeException("evaluate: expected String, got ${value.typeName()}")
    }

    private fun parseValue(s: String): Value {
        if (s.isEmpty()) {
            throw SantaRuntimeException("evaluate: empty string")
        }
        return when {
            s.startsWith("[") -> parseList(s)
            s.all { it.isDigit() || (it == '-' && s.length > 1) } -> {
                val num = s.toLongOrNull()
                    ?: throw SantaRuntimeException("evaluate: invalid integer '$s'")
                IntValue(num)
            }
            else -> throw SantaRuntimeException("evaluate: unsupported value '$s'")
        }
    }

    private fun parseList(s: String): ListValue {
        if (!s.startsWith("[") || !s.endsWith("]")) {
            throw SantaRuntimeException("evaluate: invalid list syntax '$s'")
        }
        val inner = s.substring(1, s.length - 1)
        if (inner.isEmpty()) {
            return ListValue(persistentListOf())
        }

        val elements = mutableListOf<Value>()
        var i = 0
        while (i < inner.length) {
            // Skip whitespace and commas
            while (i < inner.length && (inner[i] == ',' || inner[i] == ' ')) {
                i++
            }
            if (i >= inner.length) break

            if (inner[i] == '[') {
                // Find matching bracket
                var depth = 0
                val start = i
                while (i < inner.length) {
                    when (inner[i]) {
                        '[' -> depth++
                        ']' -> {
                            depth--
                            if (depth == 0) {
                                i++
                                break
                            }
                        }
                    }
                    i++
                }
                elements.add(parseList(inner.substring(start, i)))
            } else {
                // Parse integer
                val start = i
                if (inner[i] == '-') i++
                while (i < inner.length && inner[i].isDigit()) {
                    i++
                }
                val numStr = inner.substring(start, i)
                val num = numStr.toLongOrNull()
                    ?: throw SantaRuntimeException("evaluate: invalid integer '$numStr'")
                elements.add(IntValue(num))
            }
        }
        return ListValue(elements.toPersistentList())
    }

    /**
     * list(value) - Convert to List representation.
     */
    @JvmStatic
    fun list(value: Value): Value = when (value) {
        is ListValue -> value
        is SetValue -> ListValue(value.elements.toList().toPersistentList())
        is DictValue -> {
            // Dictionary returns list of [key, value] tuples
            val tuples = value.entries.map { (k, v) ->
                ListValue(persistentListOf(k, v))
            }
            ListValue(tuples.toPersistentList())
        }
        is StringValue -> {
            // Each grapheme cluster becomes a string element
            val graphemes = mutableListOf<Value>()
            val iter = com.ibm.icu.text.BreakIterator.getCharacterInstance()
            iter.setText(value.value)
            var start = 0
            var end = iter.next()
            while (end != com.ibm.icu.text.BreakIterator.DONE) {
                graphemes.add(StringValue(value.value.substring(start, end)))
                start = end
                end = iter.next()
            }
            ListValue(graphemes.toPersistentList())
        }
        is RangeValue -> {
            if (value.isUnbounded()) {
                throw SantaRuntimeException("list: cannot convert unbounded range to list")
            }
            ListValue(value.asSequence().toList().toPersistentList())
        }
        is LazySequenceValue -> throw SantaRuntimeException("list: cannot convert infinite LazySequence to list; use take() first")
        else -> throw SantaRuntimeException("list: cannot convert ${value.typeName()} to List")
    }

    /**
     * set(value) - Convert to Set representation.
     */
    @JvmStatic
    fun set(value: Value): Value = when (value) {
        is ListValue -> {
            // Enforce hashability
            for (elem in value.elements) {
                if (!elem.isHashable()) {
                    throw SantaRuntimeException("set: element ${elem.typeName()} is not hashable")
                }
            }
            SetValue(value.elements.toPersistentSet())
        }
        is SetValue -> value
        is StringValue -> {
            // Each grapheme cluster becomes a string element in the set
            val graphemes = mutableSetOf<Value>()
            val iter = com.ibm.icu.text.BreakIterator.getCharacterInstance()
            iter.setText(value.value)
            var start = 0
            var end = iter.next()
            while (end != com.ibm.icu.text.BreakIterator.DONE) {
                graphemes.add(StringValue(value.value.substring(start, end)))
                start = end
                end = iter.next()
            }
            SetValue(graphemes.toPersistentSet())
        }
        is RangeValue -> {
            if (value.isUnbounded()) {
                throw SantaRuntimeException("set: cannot convert unbounded range to set")
            }
            SetValue(value.asSequence().toList().toPersistentSet())
        }
        else -> throw SantaRuntimeException("set: cannot convert ${value.typeName()} to Set")
    }

    /**
     * dict(value) - Convert to Dictionary representation.
     * Accepts List of [key, value] tuples or Dictionary (identity).
     */
    @JvmStatic
    fun dict(value: Value): Value = when (value) {
        is DictValue -> value
        is ListValue -> {
            var result = persistentMapOf<Value, Value>()
            for (elem in value.elements) {
                if (elem !is ListValue || elem.size() != 2) {
                    throw SantaRuntimeException("dict: expected list of [key, value] tuples")
                }
                val key = elem.get(0)
                val v = elem.get(1)
                if (!key.isHashable()) {
                    throw SantaRuntimeException("dict: key ${key.typeName()} is not hashable")
                }
                result = result.put(key, v)
            }
            DictValue(result)
        }
        else -> throw SantaRuntimeException("dict: cannot convert ${value.typeName()} to Dictionary")
    }

    // =========================================================================
    // Collection Access Functions (LANG.txt §11.2)
    // =========================================================================

    /**
     * get(index, collection) - Get element at index. Returns nil if not found.
     */
    @JvmStatic
    fun get(index: Value, collection: Value): Value = when (collection) {
        is ListValue -> when (index) {
            is IntValue -> collection.get(index.value.toInt())
            is RangeValue -> {
                val start = index.getStart().toInt()
                val end = if (index.isUnbounded()) {
                    collection.size()
                } else {
                    index.getEndExclusive()!!.toInt()
                }
                collection.slice(start, end)
            }
            else -> throw SantaRuntimeException("get: index must be Integer or Range for List")
        }
        is SetValue -> {
            // For sets, checks membership and returns value or nil
            if (collection.contains(index)) index else NilValue
        }
        is DictValue -> collection.get(index)
        is StringValue -> when (index) {
            is IntValue -> {
                val grapheme = collection.graphemeAt(index.value.toInt())
                if (grapheme != null) StringValue(grapheme) else NilValue
            }
            is RangeValue -> {
                val start = index.getStart().toInt()
                val end = if (index.isUnbounded()) {
                    collection.graphemeLength()
                } else {
                    index.getEndExclusive()!!.toInt()
                }
                StringValue(collection.graphemeSlice(start, end))
            }
            else -> throw SantaRuntimeException("get: index must be Integer or Range for String")
        }
        is RangeValue -> {
            if (index !is IntValue) throw SantaRuntimeException("get: index must be Integer for Range")
            val idx = index.value.toInt()
            if (idx < 0) NilValue
            else collection.asSequence().drop(idx).firstOrNull() ?: NilValue
        }
        is LazySequenceValue -> {
            if (index !is IntValue) throw SantaRuntimeException("get: index must be Integer for LazySequence")
            val idx = index.value.toInt()
            if (idx < 0) NilValue
            else collection.take(idx + 1).getOrNull(idx) ?: NilValue
        }
        else -> throw SantaRuntimeException("get: expected collection, got ${collection.typeName()}")
    }

    /**
     * second(collection) - Get second element. Returns nil if fewer than 2 elements.
     */
    @JvmStatic
    fun second(value: Value): Value = when (value) {
        is ListValue -> value.get(1)
        is SetValue -> {
            val elements = value.elements.toList()
            if (elements.size >= 2) elements[1] else NilValue
        }
        is StringValue -> {
            val grapheme = value.graphemeAt(1)
            if (grapheme != null) StringValue(grapheme) else NilValue
        }
        is RangeValue -> value.asSequence().drop(1).firstOrNull() ?: NilValue
        is LazySequenceValue -> value.take(2).getOrNull(1) ?: NilValue
        else -> throw SantaRuntimeException("second: expected collection, got ${value.typeName()}")
    }

    /**
     * last(collection) - Get last element. Returns nil if empty.
     */
    @JvmStatic
    fun last(value: Value): Value = when (value) {
        is ListValue -> if (value.size() > 0) value.get(-1) else NilValue
        is SetValue -> {
            val elements = value.elements.toList()
            if (elements.isNotEmpty()) elements.last() else NilValue
        }
        is StringValue -> {
            val grapheme = value.graphemeAt(-1)
            if (grapheme != null) StringValue(grapheme) else NilValue
        }
        is RangeValue -> {
            if (value.isUnbounded()) {
                throw SantaRuntimeException("last: cannot get last of unbounded range")
            }
            value.asSequence().lastOrNull() ?: NilValue
        }
        else -> throw SantaRuntimeException("last: expected List, Set, String, or bounded Range, got ${value.typeName()}")
    }

    // =========================================================================
    // Collection Modification Functions (LANG.txt §11.3)
    // =========================================================================

    /**
     * assoc(key, value, collection) - Associate key/index with value.
     */
    @JvmStatic
    fun assoc(key: Value, newValue: Value, collection: Value): Value = when (collection) {
        is ListValue -> {
            if (key !is IntValue) throw SantaRuntimeException("assoc: index must be Integer for List")
            val idx = key.value.toInt()
            if (idx < 0) throw SantaRuntimeException("assoc: negative index not allowed")
            // Fill with nil if index beyond current size
            var elements = collection.elements
            while (elements.size <= idx) {
                elements = elements.add(NilValue)
            }
            ListValue(elements.set(idx, newValue))
        }
        is DictValue -> {
            if (!key.isHashable()) {
                throw SantaRuntimeException("assoc: key ${key.typeName()} is not hashable")
            }
            collection.put(key, newValue)
        }
        else -> throw SantaRuntimeException("assoc: expected List or Dictionary, got ${collection.typeName()}")
    }

    /**
     * update(key, updater, collection) - Update using a pure updater function.
     * The updater receives the current value (or nil if not present).
     */
    @JvmStatic
    fun update(key: Value, updater: Value, collection: Value): Value {
        if (updater !is FunctionValue) {
            throw SantaRuntimeException("update: updater must be a Function")
        }
        return when (collection) {
            is ListValue -> {
                if (key !is IntValue) throw SantaRuntimeException("update: index must be Integer for List")
                val idx = key.value.toInt()
                if (idx < 0) throw SantaRuntimeException("update: negative index not allowed")
                // Fill with nil if index beyond current size
                var elements = collection.elements
                while (elements.size <= idx) {
                    elements = elements.add(NilValue)
                }
                val currentValue = elements[idx]
                val newValue = updater.invoke(listOf(currentValue))
                ListValue(elements.set(idx, newValue))
            }
            is DictValue -> {
                if (!key.isHashable()) {
                    throw SantaRuntimeException("update: key ${key.typeName()} is not hashable")
                }
                val currentValue = collection.get(key)
                val newValue = updater.invoke(listOf(currentValue))
                collection.put(key, newValue)
            }
            else -> throw SantaRuntimeException("update: expected List or Dictionary, got ${collection.typeName()}")
        }
    }

    /**
     * update_d(key, default, updater, collection) - Update with default value.
     */
    @JvmStatic
    fun update_d(key: Value, default: Value, updater: Value, collection: Value): Value {
        if (updater !is FunctionValue) {
            throw SantaRuntimeException("update_d: updater must be a Function")
        }
        return when (collection) {
            is ListValue -> {
                if (key !is IntValue) throw SantaRuntimeException("update_d: index must be Integer for List")
                val idx = key.value.toInt()
                if (idx < 0) throw SantaRuntimeException("update_d: negative index not allowed")
                // Fill with nil if index beyond current size
                var elements = collection.elements
                while (elements.size <= idx) {
                    elements = elements.add(NilValue)
                }
                val currentValue = if (elements[idx] == NilValue) default else elements[idx]
                val newValue = updater.invoke(listOf(currentValue))
                ListValue(elements.set(idx, newValue))
            }
            is DictValue -> {
                if (!key.isHashable()) {
                    throw SantaRuntimeException("update_d: key ${key.typeName()} is not hashable")
                }
                val existing = collection.entries[key]
                val currentValue = existing ?: default
                val newValue = updater.invoke(listOf(currentValue))
                collection.put(key, newValue)
            }
            else -> throw SantaRuntimeException("update_d: expected List or Dictionary, got ${collection.typeName()}")
        }
    }

    // =========================================================================
    // String Functions (LANG.txt §11.14)
    // =========================================================================

    /**
     * lines(string) - Split string on newline characters.
     * Drops trailing empty string if present (common with files having trailing newline).
     */
    @JvmStatic
    fun lines(value: Value): Value = when (value) {
        is StringValue -> {
            var parts = value.value.split("\n").map { StringValue(it) as Value }
            // Drop trailing empty string from trailing newline
            if (parts.isNotEmpty() && (parts.last() as StringValue).value.isEmpty()) {
                parts = parts.dropLast(1)
            }
            ListValue(parts.toPersistentList())
        }
        else -> throw SantaRuntimeException("lines: expected String, got ${value.typeName()}")
    }

    /**
     * split(separator, string) - Split string by separator.
     */
    @JvmStatic
    fun split(separator: Value, str: Value): Value {
        if (separator !is StringValue) {
            throw SantaRuntimeException("split: separator must be String")
        }
        if (str !is StringValue) {
            throw SantaRuntimeException("split: second argument must be String")
        }
        val parts = if (separator.value.isEmpty()) {
            // Split into individual grapheme clusters
            val graphemes = mutableListOf<Value>()
            val iter = com.ibm.icu.text.BreakIterator.getCharacterInstance()
            iter.setText(str.value)
            var start = 0
            var end = iter.next()
            while (end != com.ibm.icu.text.BreakIterator.DONE) {
                graphemes.add(StringValue(str.value.substring(start, end)))
                start = end
                end = iter.next()
            }
            graphemes
        } else {
            str.value.split(separator.value).map { StringValue(it) as Value }
        }
        return ListValue(parts.toPersistentList())
    }

    /**
     * upper(string) - Convert string to uppercase.
     */
    @JvmStatic
    fun upper(value: Value): Value = when (value) {
        is StringValue -> StringValue(value.value.uppercase())
        else -> throw SantaRuntimeException("upper: expected String, got ${value.typeName()}")
    }

    /**
     * lower(string) - Convert string to lowercase.
     */
    @JvmStatic
    fun lower(value: Value): Value = when (value) {
        is StringValue -> StringValue(value.value.lowercase())
        else -> throw SantaRuntimeException("lower: expected String, got ${value.typeName()}")
    }

    /**
     * replace(pattern, replacement, string) - Replace all occurrences.
     */
    @JvmStatic
    fun replace(pattern: Value, replacement: Value, str: Value): Value {
        if (pattern !is StringValue) {
            throw SantaRuntimeException("replace: pattern must be String")
        }
        if (replacement !is StringValue) {
            throw SantaRuntimeException("replace: replacement must be String")
        }
        if (str !is StringValue) {
            throw SantaRuntimeException("replace: third argument must be String")
        }
        return StringValue(str.value.replace(pattern.value, replacement.value))
    }

    /**
     * join(separator, collection) - Join collection elements with separator.
     */
    @JvmStatic
    fun join(separator: Value, collection: Value): Value {
        if (separator !is StringValue) {
            throw SantaRuntimeException("join: separator must be String")
        }
        val elements = when (collection) {
            is ListValue -> collection.elements
            is SetValue -> collection.elements.toList()
            else -> throw SantaRuntimeException("join: expected List or Set, got ${collection.typeName()}")
        }
        val strings = elements.map { elem ->
            when (elem) {
                is StringValue -> elem.value
                is IntValue -> elem.value.toString()
                is DecimalValue -> elem.value.toString()
                is BoolValue -> elem.value.toString()
                is NilValue -> "nil"
                else -> elem.toString()
            }
        }
        return StringValue(strings.joinToString(separator.value))
    }

    /**
     * regex_match(pattern, string) - Match and return capture groups only.
     * Returns empty list if no match or no capture groups.
     */
    @JvmStatic
    fun regex_match(pattern: Value, str: Value): Value {
        if (pattern !is StringValue) {
            throw SantaRuntimeException("regex_match: pattern must be String")
        }
        if (str !is StringValue) {
            throw SantaRuntimeException("regex_match: second argument must be String")
        }
        val regex = try {
            Regex(pattern.value)
        } catch (e: Exception) {
            throw SantaRuntimeException("regex_match: invalid regex pattern: ${e.message}")
        }
        val matchResult = regex.find(str.value) ?: return ListValue(persistentListOf())

        // Return capture groups only (not the full match)
        val groups = matchResult.groupValues.drop(1)  // Skip group 0 (full match)
        val result = groups.map { StringValue(it) as Value }
        return ListValue(result.toPersistentList())
    }

    /**
     * regex_match_all(pattern, string) - Match all occurrences of pattern (entire match, not just groups).
     */
    @JvmStatic
    fun regex_match_all(pattern: Value, str: Value): Value {
        if (pattern !is StringValue) {
            throw SantaRuntimeException("regex_match_all: pattern must be String")
        }
        if (str !is StringValue) {
            throw SantaRuntimeException("regex_match_all: second argument must be String")
        }
        val regex = try {
            Regex(pattern.value)
        } catch (e: Exception) {
            throw SantaRuntimeException("regex_match_all: invalid regex pattern: ${e.message}")
        }
        val matches = regex.findAll(str.value).map { StringValue(it.value) as Value }.toList()
        return ListValue(matches.toPersistentList())
    }

    /**
     * md5(string) - Return the MD5 hash of a string as a lowercase hexadecimal string.
     */
    @JvmStatic
    fun md5(value: Value): Value {
        if (value !is StringValue) {
            throw SantaRuntimeException("md5: expected String, got ${value.typeName()}")
        }
        val md = java.security.MessageDigest.getInstance("MD5")
        val digest = md.digest(value.value.toByteArray(Charsets.UTF_8))
        val hexString = digest.joinToString("") { "%02x".format(it) }
        return StringValue(hexString)
    }

    // =========================================================================
    // Math Functions (LANG.txt §11.15)
    // =========================================================================

    /**
     * signum(value) - Return sign: -1 (negative), 0 (zero), or 1 (positive).
     */
    @JvmStatic
    fun signum(value: Value): Value = when (value) {
        is IntValue -> IntValue(value.value.compareTo(0L).toLong())
        is DecimalValue -> IntValue(value.value.compareTo(0.0).toLong())
        else -> throw SantaRuntimeException("signum: expected Integer or Decimal, got ${value.typeName()}")
    }

    /**
     * vec_add(a, b) - Vector addition: element-wise sum of two lists.
     */
    @JvmStatic
    fun vec_add(a: Value, b: Value): Value {
        if (a !is ListValue) throw SantaRuntimeException("vec_add: first argument must be List")
        if (b !is ListValue) throw SantaRuntimeException("vec_add: second argument must be List")
        val minLen = minOf(a.size(), b.size())
        val result = (0 until minLen).map { i ->
            Operators.add(a.get(i), b.get(i))
        }
        return ListValue(result.toPersistentList())
    }

    // =========================================================================
    // Bitwise Operations (LANG.txt §4.5)
    // =========================================================================

    /**
     * bit_and(a, b) - Bitwise AND.
     */
    @JvmStatic
    fun bit_and(a: Value, b: Value): Value {
        if (a !is IntValue) throw SantaRuntimeException("bit_and: first argument must be Integer")
        if (b !is IntValue) throw SantaRuntimeException("bit_and: second argument must be Integer")
        return IntValue(a.value and b.value)
    }

    /**
     * bit_or(a, b) - Bitwise OR.
     */
    @JvmStatic
    fun bit_or(a: Value, b: Value): Value {
        if (a !is IntValue) throw SantaRuntimeException("bit_or: first argument must be Integer")
        if (b !is IntValue) throw SantaRuntimeException("bit_or: second argument must be Integer")
        return IntValue(a.value or b.value)
    }

    /**
     * bit_xor(a, b) - Bitwise XOR.
     */
    @JvmStatic
    fun bit_xor(a: Value, b: Value): Value {
        if (a !is IntValue) throw SantaRuntimeException("bit_xor: first argument must be Integer")
        if (b !is IntValue) throw SantaRuntimeException("bit_xor: second argument must be Integer")
        return IntValue(a.value xor b.value)
    }

    /**
     * bit_not(value) - Bitwise NOT (complement).
     */
    @JvmStatic
    fun bit_not(value: Value): Value {
        if (value !is IntValue) throw SantaRuntimeException("bit_not: argument must be Integer")
        return IntValue(value.value.inv())
    }

    /**
     * bit_shift_left(value, shift) - Left shift.
     */
    @JvmStatic
    fun bit_shift_left(value: Value, shift: Value): Value {
        if (value !is IntValue) throw SantaRuntimeException("bit_shift_left: first argument must be Integer")
        if (shift !is IntValue) throw SantaRuntimeException("bit_shift_left: second argument must be Integer")
        return IntValue(value.value shl shift.value.toInt())
    }

    /**
     * bit_shift_right(value, shift) - Right shift.
     */
    @JvmStatic
    fun bit_shift_right(value: Value, shift: Value): Value {
        if (value !is IntValue) throw SantaRuntimeException("bit_shift_right: first argument must be Integer")
        if (shift !is IntValue) throw SantaRuntimeException("bit_shift_right: second argument must be Integer")
        return IntValue(value.value shr shift.value.toInt())
    }

    // =========================================================================
    // Transformation Functions (LANG.txt §11.4)
    // =========================================================================

    /**
     * map(mapper, collection) - Apply mapper to each element.
     * Returns same collection type (except String -> List).
     */
    @JvmStatic
    fun map(mapper: Value, collection: Value): Value {
        if (mapper !is FunctionValue) {
            throw SantaRuntimeException("map: mapper must be a Function")
        }
        return when (collection) {
            is ListValue -> {
                val result = collection.elements.map { mapper.invoke(listOf(it)) }
                ListValue(result.toPersistentList())
            }
            is SetValue -> {
                val result = collection.elements.map { mapper.invoke(listOf(it)) }
                SetValue(result.toPersistentSet())
            }
            is DictValue -> {
                // Mapper receives value (and optionally key)
                var result = persistentMapOf<Value, Value>()
                for ((k, v) in collection.entries) {
                    val newValue = if (mapper.arity >= 2) {
                        mapper.invoke(listOf(v, k))
                    } else {
                        mapper.invoke(listOf(v))
                    }
                    result = result.put(k, newValue)
                }
                DictValue(result)
            }
            is StringValue -> {
                // Each grapheme cluster, returns List
                val graphemes = toGraphemeList(collection.value)
                val result = graphemes.map { mapper.invoke(listOf(StringValue(it))) }
                ListValue(result.toPersistentList())
            }
            is RangeValue -> {
                // Bounded ranges return List, unbounded returns lazy sequence
                if (collection.isUnbounded()) {
                    val seq = toSequence(collection)
                    LazySequenceValue.fromSequence(seq.map { mapper.invoke(listOf(it)) })
                } else {
                    val result = collection.asSequence()
                        .map { mapper.invoke(listOf(it)) }
                        .toList()
                    ListValue(result.toPersistentList())
                }
            }
            is LazySequenceValue -> {
                // Return lazy sequence preserving finiteness
                val seq = toSequence(collection)
                LazySequenceValue.withSameFiniteness(collection, seq.map { mapper.invoke(listOf(it)) })
            }
            else -> throw SantaRuntimeException("map: expected collection, got ${collection.typeName()}")
        }
    }

    /**
     * filter(predicate, collection) - Keep elements where predicate is truthy.
     */
    @JvmStatic
    fun filter(predicate: Value, collection: Value): Value {
        if (predicate !is FunctionValue) {
            throw SantaRuntimeException("filter: predicate must be a Function")
        }
        return when (collection) {
            is ListValue -> {
                val result = collection.elements.filter { predicate.invoke(listOf(it)).isTruthy() }
                ListValue(result.toPersistentList())
            }
            is SetValue -> {
                val result = collection.elements.filter { predicate.invoke(listOf(it)).isTruthy() }
                SetValue(result.toPersistentSet())
            }
            is DictValue -> {
                // Predicate receives value (and optionally key)
                var result = persistentMapOf<Value, Value>()
                for ((k, v) in collection.entries) {
                    val keep = if (predicate.arity >= 2) {
                        predicate.invoke(listOf(v, k))
                    } else {
                        predicate.invoke(listOf(v))
                    }
                    if (keep.isTruthy()) {
                        result = result.put(k, v)
                    }
                }
                DictValue(result)
            }
            is StringValue -> {
                // Each grapheme cluster, returns List
                val graphemes = toGraphemeList(collection.value)
                val result = graphemes.filter { predicate.invoke(listOf(StringValue(it))).isTruthy() }
                    .map { StringValue(it) as Value }
                ListValue(result.toPersistentList())
            }
            is RangeValue -> {
                // Bounded ranges return List, unbounded returns lazy sequence
                if (collection.isUnbounded()) {
                    val seq = toSequence(collection)
                    LazySequenceValue.fromSequence(seq.filter { predicate.invoke(listOf(it)).isTruthy() })
                } else {
                    val result = collection.asSequence()
                        .filter { predicate.invoke(listOf(it)).isTruthy() }
                        .toList()
                    ListValue(result.toPersistentList())
                }
            }
            is LazySequenceValue -> {
                // Return lazy sequence preserving finiteness
                val seq = toSequence(collection)
                LazySequenceValue.withSameFiniteness(collection, seq.filter { predicate.invoke(listOf(it)).isTruthy() })
            }
            else -> throw SantaRuntimeException("filter: expected collection, got ${collection.typeName()}")
        }
    }

    /**
     * flat_map(mapper, collection) - Map and flatten results.
     */
    @JvmStatic
    fun flat_map(mapper: Value, collection: Value): Value {
        if (mapper !is FunctionValue) {
            throw SantaRuntimeException("flat_map: mapper must be a Function")
        }
        val items = when (collection) {
            is ListValue -> collection.elements.asSequence()
            is SetValue -> collection.elements.asSequence()
            is DictValue -> collection.entries.values.asSequence()
            is StringValue -> toGraphemeList(collection.value).map { StringValue(it) as Value }.asSequence()
            is RangeValue -> collection.asSequence()
            is LazySequenceValue -> collection.asSequence()
            else -> throw SantaRuntimeException("flat_map: expected collection, got ${collection.typeName()}")
        }
        val result = items.flatMap { item ->
            val mapped = mapper.invoke(listOf(item))
            when (mapped) {
                is ListValue -> mapped.elements.asSequence()
                is SetValue -> mapped.elements.asSequence()
                is LazySequenceValue -> mapped.asSequence()
                else -> sequenceOf(mapped)
            }
        }.toList()
        return ListValue(result.toPersistentList())
    }

    /**
     * filter_map(mapper, collection) - Map and keep only truthy results.
     */
    @JvmStatic
    fun filter_map(mapper: Value, collection: Value): Value {
        if (mapper !is FunctionValue) {
            throw SantaRuntimeException("filter_map: mapper must be a Function")
        }
        return when (collection) {
            is ListValue -> {
                val result = collection.elements.mapNotNull { elem ->
                    val mapped = mapper.invoke(listOf(elem))
                    if (mapped.isTruthy()) mapped else null
                }
                ListValue(result.toPersistentList())
            }
            is SetValue -> {
                val result = collection.elements.mapNotNull { elem ->
                    val mapped = mapper.invoke(listOf(elem))
                    if (mapped.isTruthy()) mapped else null
                }
                SetValue(result.toPersistentSet())
            }
            is DictValue -> {
                val result = collection.entries.mapNotNull { (k, v) ->
                    val mapped = if (mapper.arity >= 2) {
                        mapper.invoke(listOf(v, k))
                    } else {
                        mapper.invoke(listOf(v))
                    }
                    if (mapped.isTruthy()) k to mapped else null
                }
                DictValue(result.fold(persistentMapOf()) { acc, (k, v) -> acc.put(k, v) })
            }
            is StringValue -> {
                val graphemes = toGraphemeList(collection.value)
                val result = graphemes.mapNotNull { g ->
                    val mapped = mapper.invoke(listOf(StringValue(g)))
                    if (mapped.isTruthy()) mapped else null
                }
                ListValue(result.toPersistentList())
            }
            is RangeValue -> {
                val seq = toSequence(collection)
                // Unbounded ranges produce infinite sequences
                LazySequenceValue.fromSequence(seq.mapNotNull { elem ->
                    val mapped = mapper.invoke(listOf(elem))
                    if (mapped.isTruthy()) mapped else null
                })
            }
            is LazySequenceValue -> {
                val seq = toSequence(collection)
                // Preserve finiteness of the source
                LazySequenceValue.withSameFiniteness(collection, seq.mapNotNull { elem ->
                    val mapped = mapper.invoke(listOf(elem))
                    if (mapped.isTruthy()) mapped else null
                })
            }
            else -> throw SantaRuntimeException("filter_map: expected collection, got ${collection.typeName()}")
        }
    }

    /**
     * find_map(mapper, collection) - Find first element where mapper returns truthy, return that mapped value.
     */
    @JvmStatic
    fun find_map(mapper: Value, collection: Value): Value {
        if (mapper !is FunctionValue) {
            throw SantaRuntimeException("find_map: mapper must be a Function")
        }
        val items: Sequence<Value> = when (collection) {
            is ListValue -> collection.elements.asSequence()
            is SetValue -> collection.elements.asSequence()
            is DictValue -> {
                // For dict, we need to handle value,key pairs
                return collection.entries.entries.firstNotNullOfOrNull { (k, v) ->
                    val mapped = if (mapper.arity >= 2) {
                        mapper.invoke(listOf(v, k))
                    } else {
                        mapper.invoke(listOf(v))
                    }
                    if (mapped.isTruthy()) mapped else null
                } ?: NilValue
            }
            is StringValue -> toGraphemeList(collection.value).map { StringValue(it) as Value }.asSequence()
            is RangeValue -> collection.asSequence()
            is LazySequenceValue -> collection.asSequence()
            else -> throw SantaRuntimeException("find_map: expected collection, got ${collection.typeName()}")
        }
        return items.firstNotNullOfOrNull { elem ->
            val mapped = mapper.invoke(listOf(elem))
            if (mapped.isTruthy()) mapped else null
        } ?: NilValue
    }

    // =========================================================================
    // Reduction Functions (LANG.txt §11.5)
    // =========================================================================

    /**
     * reduce(reducer, collection) - Reduce using first element as initial accumulator.
     * Throws RuntimeErr if collection is empty.
     * Supports early exit via break.
     */
    @JvmStatic
    fun reduce(reducer: Value, collection: Value): Value {
        if (reducer !is FunctionValue) {
            throw SantaRuntimeException("reduce: reducer must be a Function")
        }
        val items = toList(collection)
        if (items.isEmpty()) {
            throw SantaRuntimeException("reduce: cannot reduce empty collection")
        }
        var acc = items.first()
        try {
            for (elem in items.drop(1)) {
                acc = reducer.invoke(listOf(acc, elem))
            }
            return acc
        } catch (e: BreakException) {
            return e.value
        }
    }

    /**
     * fold(initial, folder, collection) - Fold with explicit initial value.
     * Supports early exit via break.
     */
    @JvmStatic
    fun fold(initial: Value, folder: Value, collection: Value): Value {
        if (folder !is FunctionValue) {
            throw SantaRuntimeException("fold: folder must be a Function")
        }
        val items = when (collection) {
            is ListValue -> collection.elements.asSequence()
            is SetValue -> collection.elements.asSequence()
            is DictValue -> {
                // Folder receives acc, value (and optionally key)
                var acc = initial
                try {
                    for ((k, v) in collection.entries) {
                        acc = if (folder.arity >= 3) {
                            folder.invoke(listOf(acc, v, k))
                        } else {
                            folder.invoke(listOf(acc, v))
                        }
                    }
                    return acc
                } catch (e: BreakException) {
                    return e.value
                }
            }
            is StringValue -> toGraphemeList(collection.value).map { StringValue(it) as Value }.asSequence()
            is RangeValue -> collection.asSequence()
            is LazySequenceValue -> collection.asSequence()
            else -> throw SantaRuntimeException("fold: expected collection, got ${collection.typeName()}")
        }
        var acc = initial
        try {
            for (elem in items) {
                acc = folder.invoke(listOf(acc, elem))
            }
            return acc
        } catch (e: BreakException) {
            return e.value
        }
    }

    /**
     * fold_s(initial, folder, collection) - Fold with state.
     * Initial is a list where first element is the result and remaining elements are state.
     * Only the first element is returned at the end.
     * Supports early exit via break.
     */
    @JvmStatic
    fun fold_s(initial: Value, folder: Value, collection: Value): Value {
        if (folder !is FunctionValue) {
            throw SantaRuntimeException("fold_s: folder must be a Function")
        }
        if (initial !is ListValue) {
            throw SantaRuntimeException("fold_s: initial must be a List")
        }
        val items = when (collection) {
            is ListValue -> collection.elements.asSequence()
            is SetValue -> collection.elements.asSequence()
            is DictValue -> collection.entries.values.asSequence()
            is StringValue -> toGraphemeList(collection.value).map { StringValue(it) as Value }.asSequence()
            is RangeValue -> collection.asSequence()
            is LazySequenceValue -> collection.asSequence()
            else -> throw SantaRuntimeException("fold_s: expected collection, got ${collection.typeName()}")
        }
        var state: Value = initial
        try {
            for (elem in items) {
                state = folder.invoke(listOf(state, elem))
                if (state !is ListValue) {
                    throw SantaRuntimeException("fold_s: folder must return a List")
                }
            }
            // Return first element of final state
            return if (state is ListValue && state.size() > 0) {
                state.get(0)
            } else {
                NilValue
            }
        } catch (e: BreakException) {
            return e.value
        }
    }

    /**
     * scan(initial, folder, collection) - Return all intermediate fold results.
     * Supports early exit via break.
     */
    @JvmStatic
    fun scan(initial: Value, folder: Value, collection: Value): Value {
        if (folder !is FunctionValue) {
            throw SantaRuntimeException("scan: folder must be a Function")
        }
        val items = when (collection) {
            is ListValue -> collection.elements.toList()
            is SetValue -> collection.elements.toList()
            is DictValue -> {
                // Folder receives acc, value (and optionally key)
                val results = mutableListOf<Value>()
                var acc = initial
                try {
                    for ((k, v) in collection.entries) {
                        acc = if (folder.arity >= 3) {
                            folder.invoke(listOf(acc, v, k))
                        } else {
                            folder.invoke(listOf(acc, v))
                        }
                        results.add(acc)
                    }
                    return ListValue(results.toPersistentList())
                } catch (e: BreakException) {
                    return e.value
                }
            }
            is StringValue -> toGraphemeList(collection.value).map { StringValue(it) as Value }
            is RangeValue -> collection.asSequence().toList()
            else -> throw SantaRuntimeException("scan: expected collection, got ${collection.typeName()}")
        }
        val results = mutableListOf<Value>()
        var acc = initial
        // Include initial value in output - this deviates from LANG.txt spec but matches
        // the behavior needed by AOC solutions like Day 10 where cycles[cycle-1] expects
        // the value at START of that cycle (i.e., the initial value at index 0).
        results.add(initial)
        try {
            for (elem in items) {
                acc = folder.invoke(listOf(acc, elem))
                results.add(acc)
            }
            return ListValue(results.toPersistentList())
        } catch (e: BreakException) {
            return e.value
        }
    }

    /**
     * each(side_effect, collection) - Apply side-effecting function to each element. Returns nil.
     * Supports early exit via break.
     */
    @JvmStatic
    fun each(sideEffect: Value, collection: Value): Value {
        if (sideEffect !is FunctionValue) {
            throw SantaRuntimeException("each: function must be a Function")
        }
        val items = when (collection) {
            is ListValue -> collection.elements.asSequence()
            is SetValue -> collection.elements.asSequence()
            is DictValue -> {
                // Function receives value (and optionally key)
                try {
                    for ((k, v) in collection.entries) {
                        if (sideEffect.arity >= 2) {
                            sideEffect.invoke(listOf(v, k))
                        } else {
                            sideEffect.invoke(listOf(v))
                        }
                    }
                    return NilValue
                } catch (e: BreakException) {
                    return e.value
                }
            }
            is StringValue -> toGraphemeList(collection.value).map { StringValue(it) as Value }.asSequence()
            is RangeValue -> collection.asSequence()
            is LazySequenceValue -> collection.asSequence()
            else -> throw SantaRuntimeException("each: expected collection, got ${collection.typeName()}")
        }
        try {
            for (elem in items) {
                sideEffect.invoke(listOf(elem))
            }
            return NilValue
        } catch (e: BreakException) {
            return e.value
        }
    }

    // =========================================================================
    // Search Functions (LANG.txt §11.7)
    // =========================================================================

    /**
     * find(predicate, collection) - Find first element where predicate is truthy.
     */
    @JvmStatic
    fun find(predicate: Value, collection: Value): Value {
        if (predicate !is FunctionValue) {
            throw SantaRuntimeException("find: predicate must be a Function")
        }
        val items: Sequence<Value> = when (collection) {
            is ListValue -> collection.elements.asSequence()
            is SetValue -> collection.elements.asSequence()
            is DictValue -> {
                // Predicate receives value (and optionally key)
                for ((k, v) in collection.entries) {
                    val result = if (predicate.arity >= 2) {
                        predicate.invoke(listOf(v, k))
                    } else {
                        predicate.invoke(listOf(v))
                    }
                    if (result.isTruthy()) return v
                }
                return NilValue
            }
            is StringValue -> toGraphemeList(collection.value).map { StringValue(it) as Value }.asSequence()
            is RangeValue -> collection.asSequence()
            is LazySequenceValue -> collection.asSequence()
            else -> throw SantaRuntimeException("find: expected collection, got ${collection.typeName()}")
        }
        return items.find { predicate.invoke(listOf(it)).isTruthy() } ?: NilValue
    }

    /**
     * count(predicate, collection) - Count elements where predicate is truthy.
     */
    @JvmStatic
    fun count(predicate: Value, collection: Value): Value {
        if (predicate !is FunctionValue) {
            throw SantaRuntimeException("count: predicate must be a Function")
        }
        val c = when (collection) {
            is ListValue -> collection.elements.count { predicate.invoke(listOf(it)).isTruthy() }
            is SetValue -> collection.elements.count { predicate.invoke(listOf(it)).isTruthy() }
            is DictValue -> {
                collection.entries.count { (k, v) ->
                    val result = if (predicate.arity >= 2) {
                        predicate.invoke(listOf(v, k))
                    } else {
                        predicate.invoke(listOf(v))
                    }
                    result.isTruthy()
                }
            }
            is StringValue -> toGraphemeList(collection.value).count {
                predicate.invoke(listOf(StringValue(it))).isTruthy()
            }
            is RangeValue -> collection.asSequence().count { predicate.invoke(listOf(it)).isTruthy() }
            else -> throw SantaRuntimeException("count: expected collection, got ${collection.typeName()}")
        }
        return IntValue(c.toLong())
    }

    // =========================================================================
    // Aggregation Functions (LANG.txt §11.8)
    // =========================================================================

    /**
     * sum(collection) - Sum all numeric elements. Returns 0 for empty collections.
     */
    @JvmStatic
    fun sum(collection: Value): Value {
        val items = when (collection) {
            is ListValue -> collection.elements
            is SetValue -> collection.elements.toList()
            is DictValue -> collection.entries.values.toList()
            is RangeValue -> collection.asSequence().toList()
            is LazySequenceValue -> {
                if (!collection.isFinite()) {
                    throw SantaRuntimeException("sum: cannot sum infinite lazy sequence (use take() first)")
                }
                collection.toList()
            }
            else -> throw SantaRuntimeException("sum: expected collection, got ${collection.typeName()}")
        }
        if (items.isEmpty()) return IntValue(0)

        var hasDecimal = false
        var intSum = 0L
        var decSum = 0.0

        for (item in items) {
            when (item) {
                is IntValue -> {
                    if (hasDecimal) decSum += item.value else intSum += item.value
                }
                is DecimalValue -> {
                    if (!hasDecimal) {
                        hasDecimal = true
                        decSum = intSum.toDouble()
                    }
                    decSum += item.value
                }
                else -> throw SantaRuntimeException("sum: expected numeric elements, got ${item.typeName()}")
            }
        }
        return if (hasDecimal) DecimalValue(decSum) else IntValue(intSum)
    }

    /**
     * max(..values) - Find maximum. Can be called with multiple args or single collection.
     */
    @JvmStatic
    fun max(value: Value): Value {
        val items = when (value) {
            is ListValue -> value.elements
            is SetValue -> value.elements.toList()
            is DictValue -> value.entries.values.toList()
            is RangeValue -> value.asSequence().toList()
            else -> throw SantaRuntimeException("max: expected collection, got ${value.typeName()}")
        }
        if (items.isEmpty()) return NilValue
        return items.maxWithOrNull { a, b -> Operators.compare(a, b) } ?: NilValue
    }

    /**
     * max(a, b) - Find maximum of two values.
     */
    @JvmStatic
    fun max(a: Value, b: Value): Value {
        return if (Operators.compare(a, b) >= 0) a else b
    }

    /**
     * max(a, b, c) - Find maximum of three values.
     */
    @JvmStatic
    fun max(a: Value, b: Value, c: Value): Value {
        return max(max(a, b), c)
    }

    /**
     * max(a, b, c, d) - Find maximum of four values.
     */
    @JvmStatic
    fun max(a: Value, b: Value, c: Value, d: Value): Value {
        return max(max(a, b), max(c, d))
    }

    /**
     * min(..values) - Find minimum. Can be called with multiple args or single collection.
     */
    @JvmStatic
    fun min(value: Value): Value {
        val items = when (value) {
            is ListValue -> value.elements
            is SetValue -> value.elements.toList()
            is DictValue -> value.entries.values.toList()
            is RangeValue -> value.asSequence().toList()
            else -> throw SantaRuntimeException("min: expected collection, got ${value.typeName()}")
        }
        if (items.isEmpty()) return NilValue
        return items.minWithOrNull { a, b -> Operators.compare(a, b) } ?: NilValue
    }

    /**
     * min(a, b) - Find minimum of two values.
     */
    @JvmStatic
    fun min(a: Value, b: Value): Value {
        return if (Operators.compare(a, b) <= 0) a else b
    }

    /**
     * min(a, b, c) - Find minimum of three values.
     */
    @JvmStatic
    fun min(a: Value, b: Value, c: Value): Value {
        return min(min(a, b), c)
    }

    // =========================================================================
    // Sequence Manipulation Functions (LANG.txt §11.9)
    // =========================================================================

    /**
     * skip(n, collection) - Skip first n elements.
     */
    @JvmStatic
    fun skip(n: Value, collection: Value): Value {
        if (n !is IntValue) throw SantaRuntimeException("skip: first argument must be Integer")
        val count = n.value.toInt()
        return when (collection) {
            is ListValue -> ListValue(collection.elements.drop(count).toPersistentList())
            is SetValue -> SetValue(collection.elements.drop(count).toPersistentSet())
            is RangeValue -> ListValue(collection.asSequence().drop(count).toList().toPersistentList())
            is LazySequenceValue -> {
                // Return a new lazy sequence that skips the first count elements, preserving finiteness
                LazySequenceValue.withSameFiniteness(collection, collection.asSequence().drop(count))
            }
            else -> throw SantaRuntimeException("skip: expected collection, got ${collection.typeName()}")
        }
    }

    /**
     * take(n, collection) - Take first n elements.
     */
    @JvmStatic
    fun take(n: Value, collection: Value): Value {
        if (n !is IntValue) throw SantaRuntimeException("take: first argument must be Integer")
        val count = n.value.toInt()
        return when (collection) {
            is ListValue -> ListValue(collection.elements.take(count).toPersistentList())
            is SetValue -> ListValue(collection.elements.take(count).toPersistentList())
            is RangeValue -> ListValue(collection.asSequence().take(count).toList().toPersistentList())
            is LazySequenceValue -> ListValue(collection.take(count).toPersistentList())
            else -> throw SantaRuntimeException("take: expected collection, got ${collection.typeName()}")
        }
    }

    /**
     * sort(comparator, collection) - Sort by comparator function.
     */
    @JvmStatic
    fun sort(comparator: Value, collection: Value): Value {
        if (comparator !is FunctionValue) {
            throw SantaRuntimeException("sort: comparator must be a Function")
        }
        if (collection !is ListValue) {
            throw SantaRuntimeException("sort: expected List, got ${collection.typeName()}")
        }
        val sorted = collection.elements.sortedWith { a, b ->
            val result = comparator.invoke(listOf(a, b))
            when (result) {
                is BoolValue -> {
                    // Boolean comparator: true means a > b (a comes after b)
                    // To satisfy Java's comparator contract, we need to check both directions
                    // for equality when the first comparison returns false
                    if (result.value) {
                        1  // a > b
                    } else {
                        // Check reverse: is b > a?
                        val reverse = comparator.invoke(listOf(b, a))
                        if (reverse is BoolValue && reverse.value) {
                            -1  // b > a, so a < b
                        } else {
                            0  // neither a > b nor b > a, so a == b
                        }
                    }
                }
                is IntValue -> result.value.toInt()
                else -> 0
            }
        }
        return ListValue(sorted.toPersistentList())
    }

    /**
     * reverse(collection) - Reverse order.
     */
    @JvmStatic
    fun reverse(collection: Value): Value = when (collection) {
        is ListValue -> ListValue(collection.elements.reversed().toPersistentList())
        is StringValue -> {
            val graphemes = toGraphemeList(collection.value)
            StringValue(graphemes.reversed().joinToString(""))
        }
        is RangeValue -> ListValue(collection.asSequence().toList().reversed().map { it }.toPersistentList())
        else -> throw SantaRuntimeException("reverse: expected List, String, or Range, got ${collection.typeName()}")
    }

    /**
     * rotate(steps, collection) - Rotate list by n steps.
     * Positive = forward (last moves to start), Negative = backward (first moves to end).
     */
    @JvmStatic
    fun rotate(steps: Value, collection: Value): Value {
        if (steps !is IntValue) throw SantaRuntimeException("rotate: first argument must be Integer")
        if (collection !is ListValue) throw SantaRuntimeException("rotate: expected List, got ${collection.typeName()}")

        val n = steps.value.toInt()
        val size = collection.size()
        if (size == 0) return collection

        val normalizedN = ((n % size) + size) % size
        if (normalizedN == 0) return collection

        // Positive rotation: last n elements move to front
        val splitPoint = size - normalizedN
        val result = collection.elements.drop(splitPoint) + collection.elements.take(splitPoint)
        return ListValue(result.toPersistentList())
    }

    /**
     * chunk(size, collection) - Split into chunks of given size.
     */
    @JvmStatic
    fun chunk(chunkSize: Value, collection: Value): Value {
        if (chunkSize !is IntValue) throw SantaRuntimeException("chunk: first argument must be Integer")

        val size = chunkSize.value.toInt()
        if (size <= 0) throw SantaRuntimeException("chunk: size must be positive")

        return when (collection) {
            is ListValue -> {
                val chunks = collection.elements.chunked(size) { chunk ->
                    ListValue(chunk.toPersistentList()) as Value
                }
                ListValue(chunks.toPersistentList())
            }
            is StringValue -> {
                // Chunk by grapheme clusters
                val graphemes = mutableListOf<String>()
                val iter = com.ibm.icu.text.BreakIterator.getCharacterInstance()
                iter.setText(collection.value)
                var start = 0
                var end = iter.next()
                while (end != com.ibm.icu.text.BreakIterator.DONE) {
                    graphemes.add(collection.value.substring(start, end))
                    start = end
                    end = iter.next()
                }
                val chunks = graphemes.chunked(size) { chunk ->
                    StringValue(chunk.joinToString("")) as Value
                }
                ListValue(chunks.toPersistentList())
            }
            else -> throw SantaRuntimeException("chunk: expected List or String, got ${collection.typeName()}")
        }
    }

    // =========================================================================
    // Set Operations (LANG.txt §11.10)
    // =========================================================================

    /**
     * union(..values) - Elements in any collection.
     */
    @JvmStatic
    fun union(value: Value): Value {
        // Handle both single list of collections and single collection
        val collections = when (value) {
            is ListValue -> {
                // Check if it's a list of collections
                val first = value.elements.firstOrNull()
                if (first is ListValue || first is SetValue || first is RangeValue || first is StringValue) {
                    value.elements.toList()
                } else {
                    listOf(value)
                }
            }
            else -> listOf(value)
        }

        val result = mutableSetOf<Value>()
        for (coll in collections) {
            val items = when (coll) {
                is ListValue -> coll.elements
                is SetValue -> coll.elements
                is StringValue -> toGraphemeList(coll.value).map { StringValue(it) }
                is RangeValue -> coll.asSequence().toList()
                else -> throw SantaRuntimeException("union: expected collection, got ${coll.typeName()}")
            }
            result.addAll(items)
        }
        return SetValue(result.toPersistentSet())
    }

    /**
     * intersection(..values) - Elements in all collections.
     */
    @JvmStatic
    fun intersection(value: Value): Value {
        val collections = when (value) {
            is ListValue -> {
                if (value.elements.isNotEmpty() && (value.elements.first() is ListValue ||
                    value.elements.first() is SetValue)) {
                    value.elements.toList()
                } else {
                    listOf(value)
                }
            }
            else -> listOf(value)
        }

        if (collections.isEmpty()) return SetValue(persistentSetOf())

        val sets = collections.map { coll ->
            when (coll) {
                is ListValue -> coll.elements.toSet()
                is SetValue -> coll.elements.toSet()
                is RangeValue -> coll.asSequence().toSet()
                else -> throw SantaRuntimeException("intersection: expected collection, got ${coll.typeName()}")
            }
        }

        val result = sets.reduce { acc, set -> acc.intersect(set) }
        return SetValue(result.toPersistentSet())
    }

    /**
     * intersection(a, b) - Elements in both collections (2-arg overload).
     */
    @JvmStatic
    fun intersection(a: Value, b: Value): Value {
        val setA = when (a) {
            is ListValue -> a.elements.toSet()
            is SetValue -> a.elements.toSet()
            is RangeValue -> a.asSequence().toSet()
            else -> throw SantaRuntimeException("intersection: expected collection, got ${a.typeName()}")
        }
        val setB = when (b) {
            is ListValue -> b.elements.toSet()
            is SetValue -> b.elements.toSet()
            is RangeValue -> b.asSequence().toSet()
            else -> throw SantaRuntimeException("intersection: expected collection, got ${b.typeName()}")
        }
        return SetValue(setA.intersect(setB).toPersistentSet())
    }

    // =========================================================================
    // Predicate Functions (LANG.txt §11.11)
    // =========================================================================

    /**
     * includes?(collection, value) - Check if value is in collection.
     */
    @JvmStatic
    fun `includes?`(collection: Value, value: Value): Value {
        val found = when (collection) {
            is ListValue -> collection.elements.contains(value)
            is SetValue -> collection.contains(value)
            is DictValue -> collection.entries.containsKey(value)  // Checks keys
            is StringValue -> {
                if (value !is StringValue) false
                else collection.value.contains(value.value)
            }
            is RangeValue -> {
                if (value !is IntValue) false
                else collection.asSequence().any { it == value }
            }
            is LazySequenceValue -> collection.asSequence().contains(value)
            else -> throw SantaRuntimeException("includes?: expected collection, got ${collection.typeName()}")
        }
        return BoolValue.box(found)
    }

    /**
     * excludes?(collection, value) - Check if value is NOT in collection.
     */
    @JvmStatic
    fun `excludes?`(collection: Value, value: Value): Value {
        val included = `includes?`(collection, value)
        return BoolValue.box(!(included as BoolValue).value)
    }

    /**
     * any?(predicate, collection) - Check if any element matches predicate.
     */
    @JvmStatic
    fun `any?`(predicate: Value, collection: Value): Value {
        if (predicate !is FunctionValue) {
            throw SantaRuntimeException("any?: predicate must be a Function")
        }
        val found = when (collection) {
            is ListValue -> collection.elements.any { predicate.invoke(listOf(it)).isTruthy() }
            is SetValue -> collection.elements.any { predicate.invoke(listOf(it)).isTruthy() }
            is DictValue -> {
                collection.entries.any { (k, v) ->
                    val result = if (predicate.arity >= 2) {
                        predicate.invoke(listOf(v, k))
                    } else {
                        predicate.invoke(listOf(v))
                    }
                    result.isTruthy()
                }
            }
            is StringValue -> toGraphemeList(collection.value).any {
                predicate.invoke(listOf(StringValue(it))).isTruthy()
            }
            is RangeValue -> collection.asSequence().any { predicate.invoke(listOf(it)).isTruthy() }
            is LazySequenceValue -> collection.asSequence().any { predicate.invoke(listOf(it)).isTruthy() }
            else -> throw SantaRuntimeException("any?: expected collection, got ${collection.typeName()}")
        }
        return BoolValue.box(found)
    }

    /**
     * all?(predicate, collection) - Check if all elements match predicate.
     */
    @JvmStatic
    fun `all?`(predicate: Value, collection: Value): Value {
        if (predicate !is FunctionValue) {
            throw SantaRuntimeException("all?: predicate must be a Function")
        }
        val allMatch = when (collection) {
            is ListValue -> collection.elements.all { predicate.invoke(listOf(it)).isTruthy() }
            is SetValue -> collection.elements.all { predicate.invoke(listOf(it)).isTruthy() }
            is DictValue -> {
                collection.entries.all { (k, v) ->
                    val result = if (predicate.arity >= 2) {
                        predicate.invoke(listOf(v, k))
                    } else {
                        predicate.invoke(listOf(v))
                    }
                    result.isTruthy()
                }
            }
            is StringValue -> toGraphemeList(collection.value).all {
                predicate.invoke(listOf(StringValue(it))).isTruthy()
            }
            is RangeValue -> collection.asSequence().all { predicate.invoke(listOf(it)).isTruthy() }
            is LazySequenceValue -> collection.asSequence().all { predicate.invoke(listOf(it)).isTruthy() }
            else -> throw SantaRuntimeException("all?: expected collection, got ${collection.typeName()}")
        }
        return BoolValue.box(allMatch)
    }

    // =========================================================================
    // Lazy Sequence Generation (LANG.txt §11.12)
    // =========================================================================

    /**
     * repeat(value) - Generate infinite sequence repeating value.
     */
    @JvmStatic
    fun repeat(value: Value): Value = LazySequenceValue.repeat(value)

    /**
     * cycle(collection) - Generate infinite sequence cycling through collection.
     */
    @JvmStatic
    fun cycle(collection: Value): Value = when (collection) {
        is ListValue -> LazySequenceValue.cycle(collection.elements.toList())
        is StringValue -> LazySequenceValue.cycle(toGraphemeList(collection.value).map { StringValue(it) })
        else -> throw SantaRuntimeException("cycle: expected List or String, got ${collection.typeName()}")
    }

    /**
     * iterate(generator, initial) - Generate sequence by repeatedly applying function.
     */
    @JvmStatic
    fun iterate(generator: Value, initial: Value): Value {
        if (generator !is FunctionValue) {
            throw SantaRuntimeException("iterate: generator must be a Function")
        }
        return LazySequenceValue.iterate(initial) { generator.invoke(listOf(it)) }
    }

    /**
     * zip(collection, ..collections) - Aggregate into tuples.
     */
    @JvmStatic
    fun zip(collection: Value): Value = when (collection) {
        is ListValue -> LazySequenceValue.zip(collection.elements.toList())
        else -> LazySequenceValue.zip(listOf(collection))
    }

    /**
     * zip(collection1, collection2) - Aggregate two collections into tuples.
     */
    @JvmStatic
    fun zip(collection1: Value, collection2: Value): Value {
        return LazySequenceValue.zip(listOf(collection1, collection2))
    }

    /**
     * zip(collection1, collection2, collection3) - Aggregate three collections into tuples.
     */
    @JvmStatic
    fun zip(collection1: Value, collection2: Value, collection3: Value): Value {
        return LazySequenceValue.zip(listOf(collection1, collection2, collection3))
    }

    /**
     * zip(collection1, collection2, collection3, collection4) - Aggregate four collections into tuples.
     */
    @JvmStatic
    fun zip(collection1: Value, collection2: Value, collection3: Value, collection4: Value): Value {
        return LazySequenceValue.zip(listOf(collection1, collection2, collection3, collection4))
    }

    /**
     * combinations(size, collection) - Generate all combinations of given size.
     * Returns a LazySequence for consistency with other santa-lang implementations.
     */
    @JvmStatic
    fun combinations(size: Value, collection: Value): Value {
        if (size !is IntValue) throw SantaRuntimeException("combinations: first argument must be Integer")
        if (collection !is ListValue) throw SantaRuntimeException("combinations: expected List, got ${collection.typeName()}")

        val k = size.value.toInt()
        val items = collection.elements.toList()

        fun generateCombinations(start: Int, current: List<Value>): Sequence<Value> = sequence {
            if (current.size == k) {
                yield(ListValue(current.toPersistentList()))
            } else {
                for (i in start until items.size) {
                    yieldAll(generateCombinations(i + 1, current + items[i]))
                }
            }
        }

        return LazySequenceValue.fromFiniteSequence(generateCombinations(0, emptyList()))
    }

    /**
     * range(from, to, step) - Generate range with custom step.
     */
    @JvmStatic
    fun range(from: Value, to: Value, step: Value): Value {
        if (from !is IntValue) throw SantaRuntimeException("range: from must be Integer")
        if (to !is IntValue) throw SantaRuntimeException("range: to must be Integer")
        if (step !is IntValue) throw SantaRuntimeException("range: step must be Integer")

        val start = from.value
        val end = to.value
        val s = step.value

        if (s == 0L) throw SantaRuntimeException("range: step cannot be zero")
        if (s > 0 && start > end) throw SantaRuntimeException("range: step direction mismatch (positive step with start > end)")
        if (s < 0 && start < end) throw SantaRuntimeException("range: step direction mismatch (negative step with start < end)")

        // Generate the range as a list since it's finite (has explicit bounds)
        val result = mutableListOf<Value>()
        var current = start
        if (s > 0) {
            while (current <= end) {
                result.add(IntValue(current))
                current += s
            }
        } else {
            while (current >= end) {
                result.add(IntValue(current))
                current += s
            }
        }
        return ListValue(result.toPersistentList())
    }

    // =========================================================================
    // Utility Functions (LANG.txt §11.16)
    // =========================================================================

    /**
     * id(value) - Identity function: returns input unchanged.
     */
    @JvmStatic
    fun id(value: Value): Value = value

    /**
     * memoize(function) - Return a memoized version of the function.
     * Caches results based on arguments.
     */
    @JvmStatic
    fun memoize(function: Value): Value {
        if (function !is FunctionValue) {
            throw SantaRuntimeException("memoize: expected Function, got ${function.typeName()}")
        }
        return MemoizedFunctionValue(function)
    }

    // =========================================================================
    // Helper functions
    // =========================================================================

    private fun toGraphemeList(s: String): List<String> {
        if (s.isEmpty()) return emptyList()
        val iter = com.ibm.icu.text.BreakIterator.getCharacterInstance()
        iter.setText(s)
        val graphemes = mutableListOf<String>()
        var start = 0
        var end = iter.next()
        while (end != com.ibm.icu.text.BreakIterator.DONE) {
            graphemes.add(s.substring(start, end))
            start = end
            end = iter.next()
        }
        return graphemes
    }

    private fun toSequence(collection: Value): Sequence<Value> = when (collection) {
        is ListValue -> collection.elements.asSequence()
        is SetValue -> collection.elements.asSequence()
        is RangeValue -> collection.asSequence()
        is LazySequenceValue -> collection.asSequence()
        is StringValue -> toGraphemeList(collection.value).map { StringValue(it) as Value }.asSequence()
        else -> emptySequence()
    }

    private fun toList(collection: Value): List<Value> = when (collection) {
        is ListValue -> collection.elements.toList()
        is SetValue -> collection.elements.toList()
        is DictValue -> collection.entries.values.toList()
        is StringValue -> toGraphemeList(collection.value).map { StringValue(it) }
        is RangeValue -> collection.asSequence().toList()
        is LazySequenceValue -> {
            if (!collection.isFinite()) {
                throw SantaRuntimeException("Cannot materialize infinite lazy sequence to list (use take() first)")
            }
            collection.toList()
        }
        else -> emptyList()
    }

    // ===== External Functions =====

    /**
     * read(path) - Reads file contents.
     *
     * Supported schemes:
     * - Local files: read("./input.txt")
     * - HTTP(S): read("https://example.com/data.txt")
     * - AOC: read("aoc://year/day") - fetches puzzle input
     *
     * Returns nil if file not found or fetch fails.
     */
    @JvmStatic
    fun read(path: Value): Value {
        if (path !is StringValue) {
            throw SantaRuntimeException("read: expected String path, got ${path.typeName()}")
        }
        val pathStr = path.value
        return try {
            when {
                pathStr.startsWith("http://") || pathStr.startsWith("https://") -> {
                    val url = java.net.URI(pathStr).toURL()
                    StringValue(url.readText())
                }
                pathStr.startsWith("aoc://") -> {
                    // AOC URLs: aoc://year/day -> fetch from adventofcode.com
                    readAocInput(pathStr)
                }
                else -> {
                    // Local file path
                    val file = java.io.File(pathStr)
                    if (file.exists() && file.isFile) {
                        StringValue(file.readText())
                    } else {
                        NilValue
                    }
                }
            }
        } catch (_: Exception) {
            NilValue
        }
    }

    /**
     * Hook for capturing puts output (set by CLI for JSON/JSONL modes).
     * When non-null, puts() calls this instead of printing to stdout.
     */
    @JvmStatic
    var putsHook: ((String) -> Unit)? = null

    /**
     * puts(...values) - Prints values to stdout.
     *
     * Multiple values are separated by spaces.
     * Returns nil.
     *
     * Per LANG.txt Section 16.3.4: If puts() is called with no arguments,
     * no console event is emitted.
     */
    @JvmStatic
    fun puts(vararg values: Value): Value {
        // Per spec, puts() with no arguments emits nothing
        if (values.isEmpty()) {
            return NilValue
        }

        val output = values.joinToString(" ") { valueToString(it) }

        val hook = putsHook
        if (hook != null) {
            hook(output)
        } else {
            println(output)
        }

        return NilValue
    }

    private fun valueToString(value: Value): String = when (value) {
        is StringValue -> value.value
        is IntValue -> value.value.toString()
        is DecimalValue -> value.value.toString()
        is BoolValue -> value.value.toString()
        is NilValue -> "nil"
        is ListValue -> "[" + (0 until value.size()).map { valueToString(value.get(it)) }.joinToString(", ") + "]"
        is SetValue -> "{" + value.elements.map { valueToString(it) }.joinToString(", ") + "}"
        is DictValue -> "#{" + value.entries.entries.map { (k, v) -> "${valueToString(k)}: ${valueToString(v)}" }.joinToString(", ") + "}"
        is FunctionValue -> "<function>"
        is LazySequenceValue -> "<lazy-sequence>"
        is RangeValue -> "<range>"
        is JavaClassValue -> "<class:${value.clazz.simpleName}>"
        is JavaObjectValue -> "<java:${value.obj?.javaClass?.simpleName ?: "null"}>"
    }

    /**
     * Read AOC puzzle input from aoc://year/day URL.
     *
     * 1. Check for aoc{year}_day{dd}.input file next to the source file
     * 2. If not found, fetch from https://adventofcode.com/{year}/day/{day}/input
     * 3. Cache the fetched input to the .input file for future use
     */
    private fun readAocInput(url: String): Value {
        // Parse aoc://year/day format
        val parts = url.removePrefix("aoc://").split("/")
        if (parts.size != 2) {
            return NilValue
        }
        val year = parts[0].toIntOrNull() ?: return NilValue
        val day = parts[1].toIntOrNull() ?: return NilValue

        // Determine local .input file path next to source file
        val inputFileName = "aoc${year}_day${day.toString().padStart(2, '0')}.input"
        val localInputFile = sourceFilePath?.let { sourcePath ->
            java.io.File(sourcePath).parentFile?.let { sourceDir ->
                java.io.File(sourceDir, inputFileName)
            }
        }

        // Check for cached .input file first
        if (localInputFile?.exists() == true) {
            return StringValue(localInputFile.readText())
        }

        // Get session token for fetching
        val session = getAocSession() ?: return NilValue

        // Fetch from AOC
        return try {
            val connection = java.net.URI("https://adventofcode.com/$year/day/$day/input")
                .toURL()
                .openConnection() as java.net.HttpURLConnection
            connection.setRequestProperty("Cookie", "session=$session")
            connection.setRequestProperty("User-Agent", "santa-lang-donner/1.0")

            if (connection.responseCode == 200) {
                val content = connection.inputStream.bufferedReader().readText()
                // Cache to .input file next to source for future use
                localInputFile?.writeText(content)
                StringValue(content)
            } else {
                NilValue
            }
        } catch (_: Exception) {
            NilValue
        }
    }

    /**
     * Get AOC session token from environment or ~/.aoc_session file.
     */
    private fun getAocSession(): String? {
        // Check environment variable first
        System.getenv("AOC_SESSION")?.takeIf { it.isNotBlank() }?.let { return it }

        // Check ~/.aoc_session file
        val sessionFile = java.io.File(System.getProperty("user.home"), ".aoc_session")
        if (sessionFile.exists()) {
            val content = sessionFile.readText().trim()
            if (content.isNotBlank()) {
                return content
            }
        }

        // Check ~/.adventofcode.session file (alternative location)
        val altSessionFile = java.io.File(System.getProperty("user.home"), ".adventofcode.session")
        if (altSessionFile.exists()) {
            val content = altSessionFile.readText().trim()
            if (content.isNotBlank()) {
                return content
            }
        }

        return null
    }

    // =========================================================================
    // Java Interop Combinators
    // =========================================================================

    /**
     * require(className) - Load a Java class by name.
     *
     * Returns a JavaClassValue that can be used with `java_new`, `java_static`, etc.
     *
     * Example:
     *   let ArrayList = require("java.util.ArrayList")
     *   let Math = require("java.lang.Math")
     */
    @JvmStatic
    fun require(className: Value): Value {
        val name = when (className) {
            is StringValue -> className.value
            else -> throw SantaRuntimeException("require: expected String class name, got ${className.typeName()}")
        }
        return JavaClassValue(JavaInterop.loadClass(name))
    }

    /**
     * java_new(class, args...) - Construct a new Java object.
     *
     * Takes a JavaClassValue (from require) or class name string and constructor arguments.
     *
     * Example:
     *   let ArrayList = require("java.util.ArrayList")
     *   let list = java_new(ArrayList)
     *   let list2 = java_new(ArrayList, 10)  // with initial capacity
     */
    @JvmStatic
    fun java_new(vararg args: Value): Value {
        if (args.isEmpty()) {
            throw SantaRuntimeException("java_new: requires at least one argument (class)")
        }
        val clazz = when (val first = args[0]) {
            is JavaClassValue -> first.clazz
            is StringValue -> JavaInterop.loadClass(first.value)
            else -> throw SantaRuntimeException("java_new: first argument must be Class or String, got ${first.typeName()}")
        }
        val constructorArgs = args.drop(1)
        return JavaInterop.construct(clazz, constructorArgs)
    }

    /**
     * java_call(target, methodName, args...) - Call an instance method on a Java object.
     *
     * Example:
     *   let list = java_new(ArrayList)
     *   java_call(list, "add", 42)
     *   let size = java_call(list, "size")
     */
    @JvmStatic
    fun java_call(vararg args: Value): Value {
        if (args.size < 2) {
            throw SantaRuntimeException("java_call: requires at least 2 arguments (target, methodName)")
        }
        val target = args[0]
        val methodName = when (val m = args[1]) {
            is StringValue -> m.value
            else -> throw SantaRuntimeException("java_call: method name must be String, got ${m.typeName()}")
        }
        val methodArgs = args.drop(2)
        return JavaInterop.invokeMethod(target, methodName, methodArgs)
    }

    /**
     * java_static(class, methodName, args...) - Call a static method on a Java class.
     *
     * Example:
     *   let Math = require("java.lang.Math")
     *   let max = java_static(Math, "max", 10, 20)
     *   let abs = java_static(Math, "abs", -42)
     */
    @JvmStatic
    fun java_static(vararg args: Value): Value {
        if (args.size < 2) {
            throw SantaRuntimeException("java_static: requires at least 2 arguments (class, methodName)")
        }
        val clazz = when (val first = args[0]) {
            is JavaClassValue -> first.clazz
            is StringValue -> JavaInterop.loadClass(first.value)
            else -> throw SantaRuntimeException("java_static: first argument must be Class or String, got ${first.typeName()}")
        }
        val methodName = when (val m = args[1]) {
            is StringValue -> m.value
            else -> throw SantaRuntimeException("java_static: method name must be String, got ${m.typeName()}")
        }
        val methodArgs = args.drop(2)
        return JavaInterop.invokeStatic(clazz, methodName, methodArgs)
    }

    /**
     * java_field(target, fieldName) - Get a field value from a Java object.
     *
     * Example:
     *   let point = java_new(require("java.awt.Point"), 10, 20)
     *   let x = java_field(point, "x")
     */
    @JvmStatic
    fun java_field(target: Value, fieldName: Value): Value {
        val name = when (fieldName) {
            is StringValue -> fieldName.value
            else -> throw SantaRuntimeException("java_field: field name must be String, got ${fieldName.typeName()}")
        }
        return JavaInterop.getField(target, name)
    }

    /**
     * java_static_field(class, fieldName) - Get a static field value from a Java class.
     *
     * Example:
     *   let Integer = require("java.lang.Integer")
     *   let maxInt = java_static_field(Integer, "MAX_VALUE")
     */
    @JvmStatic
    fun java_static_field(clazz: Value, fieldName: Value): Value {
        val javaClass = when (clazz) {
            is JavaClassValue -> clazz.clazz
            is StringValue -> JavaInterop.loadClass(clazz.value)
            else -> throw SantaRuntimeException("java_static_field: first argument must be Class or String, got ${clazz.typeName()}")
        }
        val name = when (fieldName) {
            is StringValue -> fieldName.value
            else -> throw SantaRuntimeException("java_static_field: field name must be String, got ${fieldName.typeName()}")
        }
        return JavaInterop.getStaticField(javaClass, name)
    }

    /**
     * method(name, args...) - Create a function that calls a method on its first argument.
     *
     * This is the key combinator for functional-style Java interop.
     * Returns a FunctionValue that can be used in pipelines and composition.
     *
     * Example:
     *   let toUpper = method("toUpperCase")
     *   "hello" |> toUpper  // "HELLO"
     *
     *   let split = method("split", ",")
     *   "a,b,c" |> split  // ["a", "b", "c"]
     *
     *   ["hello", "world"] |> map(method("toUpperCase"))  // ["HELLO", "WORLD"]
     */
    @JvmStatic
    fun method(vararg args: Value): Value {
        if (args.isEmpty()) {
            throw SantaRuntimeException("method: requires at least one argument (method name)")
        }
        val methodName = when (val m = args[0]) {
            is StringValue -> m.value
            else -> throw SantaRuntimeException("method: first argument must be String, got ${m.typeName()}")
        }
        val partialArgs = args.drop(1)
        return JavaMethodValue(methodName, partialArgs)
    }

    /**
     * static_method(class, name, args...) - Create a function that calls a static method.
     *
     * Returns a FunctionValue that can be used in pipelines and composition.
     *
     * Example:
     *   let Math = require("java.lang.Math")
     *   let abs = static_method(Math, "abs")
     *   -42 |> abs  // 42
     *
     *   let max = static_method(Math, "max")
     *   max(10, 20)  // 20
     */
    @JvmStatic
    fun static_method(vararg args: Value): Value {
        if (args.size < 2) {
            throw SantaRuntimeException("static_method: requires at least 2 arguments (class, method name)")
        }
        val clazz = when (val first = args[0]) {
            is JavaClassValue -> first.clazz
            is StringValue -> JavaInterop.loadClass(first.value)
            else -> throw SantaRuntimeException("static_method: first argument must be Class or String, got ${first.typeName()}")
        }
        val methodName = when (val m = args[1]) {
            is StringValue -> m.value
            else -> throw SantaRuntimeException("static_method: second argument must be String, got ${m.typeName()}")
        }
        val partialArgs = args.drop(2)
        return JavaStaticMethodValue(clazz, methodName, partialArgs)
    }

    /**
     * constructor(class, args...) - Create a function that constructs instances.
     *
     * Returns a FunctionValue that creates new instances when called.
     *
     * Example:
     *   let ArrayList = constructor(require("java.util.ArrayList"))
     *   let list1 = ArrayList()
     *   let list2 = ArrayList(10)  // with capacity
     *
     *   // Or directly
     *   let StringBuilder = constructor("java.lang.StringBuilder")
     *   let sb = StringBuilder("Hello")
     */
    @JvmStatic
    fun constructor(vararg args: Value): Value {
        if (args.isEmpty()) {
            throw SantaRuntimeException("constructor: requires at least one argument (class)")
        }
        val clazz = when (val first = args[0]) {
            is JavaClassValue -> first.clazz
            is StringValue -> JavaInterop.loadClass(first.value)
            else -> throw SantaRuntimeException("constructor: first argument must be Class or String, got ${first.typeName()}")
        }
        val partialArgs = args.drop(1)
        return JavaConstructorValue(clazz, partialArgs)
    }

    /**
     * field_accessor(name) - Create a function that accesses a field on its argument.
     *
     * Returns a FunctionValue that can be used in pipelines.
     *
     * Example:
     *   let getX = field_accessor("x")
     *   point |> getX  // gets point.x
     */
    @JvmStatic
    fun field_accessor(name: Value): Value {
        val fieldName = when (name) {
            is StringValue -> name.value
            else -> throw SantaRuntimeException("field_accessor: argument must be String, got ${name.typeName()}")
        }
        return JavaFieldAccessorValue(fieldName)
    }

    /**
     * Lookup table for built-in functions by name.
     * Maps name -> (arity, function reference)
     */
    val registry: Map<String, BuiltinInfo> = mapOf(
        // Existing
        "size" to BuiltinInfo(1, Builtins::size),
        "first" to BuiltinInfo(1, Builtins::first),
        "rest" to BuiltinInfo(1, Builtins::rest),
        "push" to BuiltinInfo(2, Builtins::push),
        "int" to BuiltinInfo(1, Builtins::int),
        "type" to BuiltinInfo(1, Builtins::type),
        "keys" to BuiltinInfo(1, Builtins::keys),
        "values" to BuiltinInfo(1, Builtins::values),
        "abs" to BuiltinInfo(1, Builtins::abs),
        // Type conversion
        "ints" to BuiltinInfo(1, Builtins::ints),
        "list" to BuiltinInfo(1, Builtins::list),
        "set" to BuiltinInfo(1, Builtins::set),
        "dict" to BuiltinInfo(1, Builtins::dict),
        "evaluate" to BuiltinInfo(1, Builtins::evaluate),
        // Collection access
        "get" to BuiltinInfo(2, Builtins::get),
        "second" to BuiltinInfo(1, Builtins::second),
        "last" to BuiltinInfo(1, Builtins::last),
        // Collection modification
        "assoc" to BuiltinInfo(3, Builtins::assoc),
        "update" to BuiltinInfo(3, Builtins::update),
        "update_d" to BuiltinInfo(4, Builtins::update_d),
        // Transformation
        "map" to BuiltinInfo(2, Builtins::map),
        "filter" to BuiltinInfo(2, Builtins::filter),
        "flat_map" to BuiltinInfo(2, Builtins::flat_map),
        "filter_map" to BuiltinInfo(2, Builtins::filter_map),
        "find_map" to BuiltinInfo(2, Builtins::find_map),
        // Reduction
        "reduce" to BuiltinInfo(2, Builtins::reduce),
        "fold" to BuiltinInfo(3, Builtins::fold),
        "fold_s" to BuiltinInfo(3, Builtins::fold_s),
        "scan" to BuiltinInfo(3, Builtins::scan),
        "each" to BuiltinInfo(2, Builtins::each),
        // Search
        "find" to BuiltinInfo(2, Builtins::find),
        "count" to BuiltinInfo(2, Builtins::count),
        // Aggregation
        "sum" to BuiltinInfo(1, Builtins::sum),
        "max" to BuiltinInfo(1, { v: Value -> max(v) }),
        "min" to BuiltinInfo(1, { v: Value -> min(v) }),
        // Sequence manipulation
        "skip" to BuiltinInfo(2, Builtins::skip),
        "take" to BuiltinInfo(2, Builtins::take),
        "sort" to BuiltinInfo(2, Builtins::sort),
        "reverse" to BuiltinInfo(1, Builtins::reverse),
        "rotate" to BuiltinInfo(2, Builtins::rotate),
        "chunk" to BuiltinInfo(2, Builtins::chunk),
        // Set operations
        "union" to BuiltinInfo(1, Builtins::union),
        "intersection" to BuiltinInfo(1, { v: Value -> intersection(v) }),
        // Predicates
        "includes?" to BuiltinInfo(2, Builtins::`includes?`),
        "excludes?" to BuiltinInfo(2, Builtins::`excludes?`),
        "any?" to BuiltinInfo(2, Builtins::`any?`),
        "all?" to BuiltinInfo(2, Builtins::`all?`),
        // Lazy sequences
        "repeat" to BuiltinInfo(1, Builtins::repeat),
        "cycle" to BuiltinInfo(1, Builtins::cycle),
        "iterate" to BuiltinInfo(2, Builtins::iterate),
        "zip" to BuiltinInfo(2, { _: Value -> throw SantaRuntimeException("zip requires at least 2 arguments") }),
        "combinations" to BuiltinInfo(2, Builtins::combinations),
        "range" to BuiltinInfo(3, Builtins::range),
        // String functions
        "lines" to BuiltinInfo(1, Builtins::lines),
        "split" to BuiltinInfo(2, Builtins::split),
        "upper" to BuiltinInfo(1, Builtins::upper),
        "lower" to BuiltinInfo(1, Builtins::lower),
        "replace" to BuiltinInfo(3, Builtins::replace),
        "join" to BuiltinInfo(2, Builtins::join),
        "regex_match" to BuiltinInfo(2, Builtins::regex_match),
        "regex_match_all" to BuiltinInfo(2, Builtins::regex_match_all),
        "md5" to BuiltinInfo(1, Builtins::md5),
        // Math
        "signum" to BuiltinInfo(1, Builtins::signum),
        "vec_add" to BuiltinInfo(2, Builtins::vec_add),
        // Bitwise operations
        "bit_and" to BuiltinInfo(2, Builtins::bit_and),
        "bit_or" to BuiltinInfo(2, Builtins::bit_or),
        "bit_xor" to BuiltinInfo(2, Builtins::bit_xor),
        "bit_not" to BuiltinInfo(1, Builtins::bit_not),
        "bit_shift_left" to BuiltinInfo(2, Builtins::bit_shift_left),
        "bit_shift_right" to BuiltinInfo(2, Builtins::bit_shift_right),
        // Utility
        "id" to BuiltinInfo(1, Builtins::id),
        "memoize" to BuiltinInfo(1, Builtins::memoize),
        // Java Interop
        "require" to BuiltinInfo(1, Builtins::require),
        "java_new" to BuiltinInfo(-1, Builtins::java_new),  // variadic
        "java_call" to BuiltinInfo(-1, Builtins::java_call),  // variadic
        "java_static" to BuiltinInfo(-1, Builtins::java_static),  // variadic
        "java_field" to BuiltinInfo(2, Builtins::java_field),
        "java_static_field" to BuiltinInfo(2, Builtins::java_static_field),
        "method" to BuiltinInfo(-1, Builtins::method),  // variadic
        "static_method" to BuiltinInfo(-1, Builtins::static_method),  // variadic
        "constructor" to BuiltinInfo(-1, Builtins::constructor),  // variadic
        "field_accessor" to BuiltinInfo(1, Builtins::field_accessor),
    )
}

/**
 * Info about a built-in function.
 */
data class BuiltinInfo(
    val arity: Int,
    val function: Any, // KFunction reference
)

/**
 * Partially applied builtin function.
 *
 * When a builtin is called with fewer arguments than expected,
 * this wrapper captures the partial arguments and waits for the rest.
 */
class PartiallyAppliedBuiltinValue(
    val name: String,
    val partialArgs: List<Value>
) : FunctionValue(
    (Builtins.registry[name]?.arity ?: throw SantaRuntimeException("Unknown builtin: $name")) - partialArgs.size
) {
    override fun invoke(args: List<Value>): Value {
        // Combine partial args with new args and invoke the full builtin
        val fullArgs = partialArgs + args
        return BuiltinFunctionValue(name).invoke(fullArgs)
    }
}

/**
 * Wrapper to use a builtin as a first-class FunctionValue.
 *
 * This allows builtins to be passed to pipeline/compose operators
 * or stored in variables and called later.
 *
 * Supports partial application: if called with fewer args than expected,
 * returns a PartiallyAppliedBuiltinValue.
 */
class BuiltinFunctionValue(val name: String) : FunctionValue(
    Builtins.registry[name]?.arity ?: throw SantaRuntimeException("Unknown builtin: $name")
) {
    override fun invoke(args: List<Value>): Value {
        // Delegate to the static builtin invocation
        return when (name) {
            // 1-arity functions
            "size" -> Builtins.size(args[0])
            "first" -> Builtins.first(args[0])
            "rest" -> Builtins.rest(args[0])
            "int" -> Builtins.int(args[0])
            "type" -> Builtins.type(args[0])
            "keys" -> Builtins.keys(args[0])
            "values" -> Builtins.values(args[0])
            "abs" -> Builtins.abs(args[0])
            "ints" -> Builtins.ints(args[0])
            "list" -> Builtins.list(args[0])
            "set" -> Builtins.set(args[0])
            "dict" -> Builtins.dict(args[0])
            "second" -> Builtins.second(args[0])
            "last" -> Builtins.last(args[0])
            "sum" -> Builtins.sum(args[0])
            "max" -> when (args.size) {
                1 -> Builtins.max(args[0])
                2 -> Builtins.max(args[0], args[1])
                3 -> Builtins.max(args[0], args[1], args[2])
                else -> throw SantaRuntimeException("max: expected 1-3 arguments, got ${args.size}")
            }
            "min" -> when (args.size) {
                1 -> Builtins.min(args[0])
                2 -> Builtins.min(args[0], args[1])
                3 -> Builtins.min(args[0], args[1], args[2])
                else -> throw SantaRuntimeException("min: expected 1-3 arguments, got ${args.size}")
            }
            "reverse" -> Builtins.reverse(args[0])
            "union" -> Builtins.union(args[0])
            "intersection" -> when (args.size) {
                1 -> Builtins.intersection(args[0])
                2 -> Builtins.intersection(args[0], args[1])
                else -> throw SantaRuntimeException("intersection: expected 1-2 arguments, got ${args.size}")
            }
            "repeat" -> Builtins.repeat(args[0])
            "cycle" -> Builtins.cycle(args[0])
            "lines" -> Builtins.lines(args[0])
            "upper" -> Builtins.upper(args[0])
            "lower" -> Builtins.lower(args[0])
            "md5" -> Builtins.md5(args[0])
            "signum" -> Builtins.signum(args[0])
            "bit_not" -> Builtins.bit_not(args[0])
            "id" -> Builtins.id(args[0])
            "memoize" -> Builtins.memoize(args[0])
            "evaluate" -> Builtins.evaluate(args[0])

            // 2-arity functions
            "push" -> Builtins.push(args[0], args[1])
            "get" -> Builtins.get(args[0], args[1])
            "map" -> Builtins.map(args[0], args[1])
            "filter" -> Builtins.filter(args[0], args[1])
            "flat_map" -> Builtins.flat_map(args[0], args[1])
            "filter_map" -> Builtins.filter_map(args[0], args[1])
            "find_map" -> Builtins.find_map(args[0], args[1])
            "reduce" -> Builtins.reduce(args[0], args[1])
            "each" -> Builtins.each(args[0], args[1])
            "find" -> Builtins.find(args[0], args[1])
            "count" -> Builtins.count(args[0], args[1])
            "skip" -> Builtins.skip(args[0], args[1])
            "take" -> Builtins.take(args[0], args[1])
            "sort" -> Builtins.sort(args[0], args[1])
            "rotate" -> Builtins.rotate(args[0], args[1])
            "chunk" -> Builtins.chunk(args[0], args[1])
            "includes?" -> Builtins.`includes?`(args[0], args[1])
            "excludes?" -> Builtins.`excludes?`(args[0], args[1])
            "any?" -> Builtins.`any?`(args[0], args[1])
            "all?" -> Builtins.`all?`(args[0], args[1])
            "iterate" -> Builtins.iterate(args[0], args[1])
            "zip" -> when (args.size) {
                1 -> Builtins.zip(args[0])
                2 -> Builtins.zip(args[0], args[1])
                3 -> Builtins.zip(args[0], args[1], args[2])
                else -> {
                    // For more than 3 args, create a list and call the 1-arg version
                    val listOfCollections = ListValue(args.toPersistentList())
                    LazySequenceValue.zip(args.toList())
                }
            }
            "combinations" -> Builtins.combinations(args[0], args[1])
            "split" -> Builtins.split(args[0], args[1])
            "join" -> Builtins.join(args[0], args[1])
            "regex_match" -> Builtins.regex_match(args[0], args[1])
            "regex_match_all" -> Builtins.regex_match_all(args[0], args[1])
            "vec_add" -> Builtins.vec_add(args[0], args[1])
            "bit_and" -> Builtins.bit_and(args[0], args[1])
            "bit_or" -> Builtins.bit_or(args[0], args[1])
            "bit_xor" -> Builtins.bit_xor(args[0], args[1])
            "bit_shift_left" -> Builtins.bit_shift_left(args[0], args[1])
            "bit_shift_right" -> Builtins.bit_shift_right(args[0], args[1])

            // 3-arity functions
            "assoc" -> Builtins.assoc(args[0], args[1], args[2])
            "update" -> Builtins.update(args[0], args[1], args[2])
            "fold" -> Builtins.fold(args[0], args[1], args[2])
            "fold_s" -> Builtins.fold_s(args[0], args[1], args[2])
            "scan" -> Builtins.scan(args[0], args[1], args[2])
            "replace" -> Builtins.replace(args[0], args[1], args[2])
            "range" -> Builtins.range(args[0], args[1], args[2])

            // 4-arity functions
            "update_d" -> Builtins.update_d(args[0], args[1], args[2], args[3])

            // Java Interop (variadic)
            "require" -> Builtins.require(args[0])
            "java_new" -> Builtins.java_new(*args.toTypedArray())
            "java_call" -> Builtins.java_call(*args.toTypedArray())
            "java_static" -> Builtins.java_static(*args.toTypedArray())
            "java_field" -> Builtins.java_field(args[0], args[1])
            "java_static_field" -> Builtins.java_static_field(args[0], args[1])
            "method" -> Builtins.method(*args.toTypedArray())
            "static_method" -> Builtins.static_method(*args.toTypedArray())
            "constructor" -> Builtins.constructor(*args.toTypedArray())
            "field_accessor" -> Builtins.field_accessor(args[0])

            else -> throw SantaRuntimeException("Builtin not yet supported as first-class value: $name")
        }
    }

    companion object {
        /** Cache of builtin wrappers for efficiency. */
        private val cache = mutableMapOf<String, BuiltinFunctionValue>()

        /** Get or create a wrapper for the given builtin name. */
        @JvmStatic
        fun get(name: String): BuiltinFunctionValue {
            return cache.getOrPut(name) { BuiltinFunctionValue(name) }
        }
    }
}
